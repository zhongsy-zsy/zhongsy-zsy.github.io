<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简历制作</title>
      <link href="/2022/07/19/mian-shi/jian-li-zhi-zuo/"/>
      <url>/2022/07/19/mian-shi/jian-li-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<h2><span id="简历内容">简历内容</span></h2><ol><li>个人信息</li><li>教育经历</li><li>实习经历</li><li>项目经历</li><li>专业技能</li><li>其他</li></ol><p>&#x3D;&#x3D;所有的尽量写在一页上，实习经历，专业技能，项目经历要占到2&#x2F;3，排版简洁，不要花里胡哨&#x3D;&#x3D;</p><h3><span id="个人信息">个人信息</span></h3><p>联系方式很重要，一般要两个，一个手机号一个邮箱，照片可有可无(可以不用放)</p><p>常见问题：个人信息占比太大，民族，党员不用写，<code> github</code> <code>csdn</code>地址可以放在最后</p><h3><span id="教育经历">教育经历</span></h3><p>专业排名，成绩排名(没有太好就不要写)，顺序就是先写最近的再写本科的经历，不是重要的信息就简化，&#x3D;&#x3D;注意TOP 20%代表专业排名还是成绩排名&#x3D;&#x3D;</p><h3><span id="实习经历">实习经历</span></h3><p>实习的时间，职位，工作</p><p>工作要简短指标化，<code>STAR法则</code>&#x3D;&#x3D;情景，任务，行动，结果&#x3D;&#x3D; 。用指标去量化他，性能提升多少等等。体现出学到的内容以及某些方面的提升</p><h3><span id="项目经历">项目经历</span></h3><p>把重点的放在最前面，&#x3D;&#x3D;写进去的一定要懂、要明白，含金量高的放在第一位&#x3D;&#x3D;</p><p>&#x3D;&#x3D;面试官一般会要求有别的东西，有没有扩展，小项目也可以写，<font color="red">一定要体现出,根据自己的爱好去学习这个项目，从在这个项目中学到了什么东西，能力的提升</font>，项目不用太多一个到三个&#x3D;&#x3D;</p><p>主要有以下三个内容</p><ol><li>项目背景(一句话说完)</li><li>简述负责的内容(要贯穿知识点，比如使用XXX技术，解决了XXX)</li><li>使用到的技术栈，遇到的问题，怎么解决，最终达到什么效果(具体化)，例如：&#x3D;&#x3D;原来使用select io复用3000 后面使用epoll达到10000&#x3D;&#x3D;</li></ol><pre><code>要有对比，说明优劣，最后得出结论要思考有没有可以优化的地方，以后的改进方向面试官是很喜欢有扩展的定西</code></pre><p>&#x3D;&#x3D;特别注意要分点进行解答，比如1. 2. 3.&#x3D;&#x3D;</p><p>举例</p><pre class=" language-c++"><code class="language-c++">项目描述： 一个用于XXX系统，支持多设备管理，整个系统主要由XX系统，XX系统，XX系统，XX系统组合而成。最终实现XXX涉及技术: Linux OpenCV Cmake C/C++ Ros  Yolo Pytorch Cuda MarkDown- 使用JSON文件格式进行系统参数配置。- 使用外观者设计模式管理四个子系统，完善代码架构。- 使用线程池技术，充分利用多核性能，采用生产者-消费者模型进行数据处理使系统障碍物检测达28FPS。- 使用OpenCV对深度图像进行处理，XXX普通障碍物检测系统。- 使用智能指针，同时使用RAII手法，自动获取释放资源。- 使用Pytorch语言采用Ghost框架训练二分类模型，使用YoloV5框架训练XXX。- 使用TensorRT进行加速部署到Nano开发板上。- 使用MarkDown进行相关测试和说明文档的书写。</code></pre><h3><span id="专业技能">专业技能</span></h3><p>要进行适当的的扩展，要注意用词，自己不熟悉的千万不要写熟悉</p><pre><code>基础-&gt;进阶-&gt;高阶了解-&gt;熟练-&gt;掌握(熟练掌握)</code></pre><p>&#x3D;&#x3D;写到简历一定要会&#x3D;&#x3D;，不要泛泛而谈，要简单扩展。</p><p>在一个范围内的，不要都写出来，留一两个，防止面试官拓展。</p><p>eg，熟悉排序算法，快排、堆排序、希尔排序。(别的排序也要知道，但是不用都写出来，留几个)</p><p>&#x3D;&#x3D;写5-8条，不要太多&#x3D;&#x3D;</p><h3><span id="其他">其他</span></h3><p>不要千篇一律写自己，热爱学习，吃苦耐劳。这些别人跟你不了解根本不会去看的。你应该体现出你的习惯适合这份工作。自己是一个成长型人才。</p><p>eg</p><ol><li>写英语等级。</li><li>贴上博客地址，多少原创文章，多少阅读量以及多少排名</li><li>自己阅读过多少技术书籍，喜欢定期总结反思。</li></ol><p>最后，一定要复查简历，确保无错别字。同时，准备多份简历，在投递岗位的时候，要充分阅读JD并及时调整简历内容，使自己更加匹配岗位。</p><h3><span id="示例">示例</span></h3><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220719124605027.png" alt="image-20220719124605027" style="zoom:50%;"><h2><span id><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220719124358966.png" alt="image-20220719124358966"></span></h2><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220719124437087.png" alt="image-20220719124437087" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2022第297周周赛</title>
      <link href="/2022/06/25/yu-yan/leetcode/zhou-sai/2022-di-28-zhou-zhou-sai/"/>
      <url>/2022/06/25/yu-yan/leetcode/zhou-sai/2022-di-28-zhou-zhou-sai/</url>
      
        <content type="html"><![CDATA[<h1><span id="2022-第297周周赛">2022 第297周周赛</span></h1><p>[toc]</p><h2><span id="2303-计算应缴税款总额"></span></h2><p>难度简单5收藏分享切换为英文接收动态反馈</p><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10-5</code> 的结果将被视作正确答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：brackets = [[3,50],[7,10],[12,25]], income = 10输出：2.65000解释：前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：brackets = [[1,0],[4,25],[5,50]], income = 2输出：0.25000解释：前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。需要支付的税款总计 $0 + $0.25 = $0.25 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：brackets = [[2,50]], income = 0输出：0.00000解释：没有收入，无需纳税，需要支付的税款总计 $0 。</code></pre><p>解题，就是简单的模拟，并没有太多的技巧。主要训练思维逻辑</p><ol><li>如果没有超过uper,那么剩余部分按照该汇率</li><li>如果超过，超过部分另算，中间区间部分按照该汇率</li></ol><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    double calculateTax(vector<vector<int>>& brackets, int income) &#123;        double res = 0;        int remain = income;        for(int i=0;i<brackets.size();i++) &#123; int uper="brackets[i][0];" percentage="brackets[i][1];" if(income>= uper) &#123;                if(i==0) &#123;                    res += (uper*percentage)/100.0;                    remain -= uper;                &#125; else &#123;                    res += (uper - brackets[i-1][0])*percentage/100.0;                    remain -= uper-brackets[i-1][0];                &#125;            &#125; else &#123;                res += remain*percentage/100.0;                break;            &#125;        &#125;        return res;    &#125;&#125;;</brackets.size();i++)></vector<int></code></pre><h2><span id="2304-网格中的最小路径代价"></span></h2><p>难度中等12收藏分享切换为英文接收动态反馈</p><p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, …, <code>(x + 1, n - 1)</code> 中的任何一个单元格。<strong>注意：</strong> 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p><p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价<em>。</em></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png" alt="img"></p><pre><code>输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]输出：17解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。- 路径途经单元格值之和 5 + 0 + 1 = 6 。- 从 5 移动到 0 的代价为 3 。- 从 0 移动到 1 的代价为 8 。路径总代价为 6 + 3 + 8 = 17 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]输出：6解释：最小代价的路径是 2 -&gt; 3 。 - 路径途经单元格值之和 2 + 3 = 5 。 - 从 2 移动到 3 的代价为 1 。 路径总代价为 5 + 1 = 6 。</code></pre><p>这个个选择问题：</p><p>首先暴力解法，就不不断的选择，然后选取最小的结果，当然可以剪枝。</p><p>我们可以自底向上，也就是动态规划</p><p>dp[i][j]表示到达 （i，j）的最小代价，之后就可以根据这个含义去进行递推</p><pre><code>class Solution &#123;public:    int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; moveCost) &#123;        // 动态规划 dp[i][j] 代表到达i，j位置的最小代价        vector&lt;vector&lt;int&gt;&gt; dp(grid.size(), vector&lt;int&gt;(grid[0].size() , 0));        for(int i=0; i&lt;grid[0].size();i++) &#123;            dp[0][i] = grid[0][i];        &#125;        for(int i=1; i&lt;grid.size();i++) &#123;            for(int j=0; j&lt;grid[0].size(); j++) &#123;                for(int k=0; k&lt;grid[0].size(); k++) &#123;                    int lastVal = grid[i-1][k];                    int nowVal = grid[i][j];                    int cost = dp[i-1][k] + moveCost[lastVal][j] + nowVal;                    dp[i][j] = dp[i][j] == 0 ? cost : min(dp[i][j], cost);                &#125;            &#125;        &#125;        int minVal = dp[grid.size()-1][0];        for(int i=0;i&lt;grid[0].size();i++) &#123;            minVal = min(minVal, dp[grid.size()-1][i]);        &#125;        return minVal;            &#125;&#125;;</code></pre><h2><span id="2305-公平分发饼干"></span></h2><p>难度中等25收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p><p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p><p>返回所有分发的最小不公平程度。</p><p><strong>示例 1：</strong></p><pre><code>输入：cookies = [8,15,10,20,8], k = 2输出：31解释：一种最优方案是 [8,15,8] 和 [10,20] 。- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。分发的不公平程度为 max(31,30) = 31 。可以证明不存在不公平程度小于 31 的分发方案。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：cookies = [6,1,3,2,2,4,1,2], k = 3输出：7解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 - 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。分发的不公平程度为 max(7,7,7) = 7 。可以证明不存在不公平程度小于 7 的分发方案。</code></pre><p>解法： 暴力加剪枝，就是通过不断的分配求解出所有的组合，在选出最优组合</p><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    // 分发饼干    // 1. 所有零食包必须分发，同一个零食包中的所有饼干只能发给一个好走     // 返回最小的不公平程度，其实就是两包尽可能的平均    // 其实也可以变为一个背包问题    int minVal = INT_MAX;    int distributeCookies(vector<int>& cookies, int k) &#123;        queue<int> que;        for(auto v : cookies) &#123;            que.push(v);        &#125;           vector<int> money(k,0);        backtrack(money,que);        return minVal;    &#125;    void backtrack(vector<int>& money, queue<int>& cookies) &#123;        if(cookies.empty()) &#123;            int val = *max_element(money.begin(),money.end());            minVal = min(val, minVal);            return;        &#125;        int v = cookies.front();        cookies.pop();        for(int i=0; i< money.size();i++) &#123;            money[i] += v;            if(money[i] > minVal) &#123;                money[i] -= v;                continue;            &#125;            backtrack(money,cookies);            money[i] -= v;        &#125;        cookies.push(v);    &#125; &#125;;</int></int></int></int></int></code></pre><h2><span id="2306-公司命名"></span></h2><p>难度困难29收藏分享切换为英文接收动态反馈</p><p>给你一个字符串数组 <code>ideas</code> 表示在公司命名过程中使用的名字列表。公司命名流程如下：</p><ol><li>从 <code>ideas</code> 中选择 2 个 <strong>不同</strong> 名字，称为 <code>ideaA</code> 和 <code>ideaB</code> 。</li><li>交换 <code>ideaA</code> 和 <code>ideaB</code> 的首字母。</li><li>如果得到的两个新名字 <strong>都</strong> 不在 <code>ideas</code> 中，那么 <code>ideaA ideaB</code>（<strong>串联</strong> <code>ideaA</code> 和 <code>ideaB</code> ，中间用一个空格分隔）是一个有效的公司名字。</li><li>否则，不是一个有效的名字。</li></ol><p>返回 <strong>不同</strong> 且有效的公司名字的数目。</p><p><strong>示例 1：</strong></p><pre><code>输入：ideas = [&quot;coffee&quot;,&quot;donuts&quot;,&quot;time&quot;,&quot;toffee&quot;]输出：6解释：下面列出一些有效的选择方案：- (&quot;coffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee conuts&quot; 。- (&quot;donuts&quot;, &quot;coffee&quot;)：对应的公司名字是 &quot;conuts doffee&quot; 。- (&quot;donuts&quot;, &quot;time&quot;)：对应的公司名字是 &quot;tonuts dime&quot; 。- (&quot;donuts&quot;, &quot;toffee&quot;)：对应的公司名字是 &quot;tonuts doffee&quot; 。- (&quot;time&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;dime tonuts&quot; 。- (&quot;toffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee tonuts&quot; 。因此，总共有 6 个不同的公司名字。下面列出一些无效的选择方案：- (&quot;coffee&quot;, &quot;time&quot;)：在原数组中存在交换后形成的名字 &quot;toffee&quot; 。- (&quot;time&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。- (&quot;coffee&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：ideas = [&quot;lack&quot;,&quot;back&quot;]输出：0解释：不存在有效的选择方案。因此，返回 0 。</code></pre><p>关键是这样的。</p><p>设置pre[i][j] 代表的含义就是，将首字母i变为j后不在队列中的idea个数</p><p>这时候就知道，如果pre[j][i] 代表的是将首字母从j变成i后不在队列的idea的个数</p><p>含义就是 axx 与 bxxx相互交换首字母后都不在队列里面。</p><pre><code>using ll = long long;class Solution &#123;public:    long long distinctNames(vector&lt;string&gt;&amp; ideas) &#123;        unordered_set&lt;string&gt; s(ideas.begin(), ideas.end());        vector&lt;vector&lt;ll&gt;&gt; cnt(26, vector&lt;ll&gt;(26));        for(string&amp; is : ideas)&#123;            int pre = is[0] - &#39;a&#39;;            for(int i = 0; i &lt; 26; ++i)&#123;                is[0] = (i + &#39;a&#39;);                if(!s.count(is)) cnt[pre][i]++;            &#125;        &#125;        ll ans = 0;        for(int i = 0; i &lt; 26; ++i)&#123;            for(int j = 0; j &lt; 26; ++j) ans += cnt[i][j] * cnt[j][i];        &#125;        return ans;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dfs 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake是如何工作的</title>
      <link href="/2022/06/21/yu-yan/cmake/cmake-shi-ru-he-gong-zuo-de/"/>
      <url>/2022/06/21/yu-yan/cmake/cmake-shi-ru-he-gong-zuo-de/</url>
      
        <content type="html"><![CDATA[<h1><span id="cmake是如何工作的">CMake是如何工作的</span></h1><p>[toc]</p><p>出错不要慌，首先一定要仔细看报错。在根据报错去解决问题。一定要学会用二分法先定位到问题是哪个地方出来的。</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220621211809803.png" alt="image-20220621211809803"></p><p>首先从图中可以知道，出错是在编译 transport_receiver这个target的时候。但是去找transport_receiver的时候发现包含了头文件目录。</p><p>仔细看FAILED 的信息</p><p>Building CXX object build_report_sdk&#x2F;CMakeFiles&#x2F;reportsdk.dir&#x2F;<strong>&#x2F;</strong>&#x2F;dispatch_queue.cpp.o</p><p>因为CMakeFiles中的文件才是最后编译的参数，进入找到相应的文件，然后根据错误再去修正。</p><p>根据错误，知道是CMakeFiles下面的reportsdk这个target编译的时候找不到头文件。之后找到这个generator产生的编译表示产物，看一下是否真的没有-I参数指定对应的目录。如果没有就找到该targrt添加并重新编译。</p><h2><span id="cmake由来">CMake由来</span></h2><p>Cmake是一个build system。经过多面的发展已经发展为一个系列。开发工具包括CMake、Cpack、CTest、CDash。具体可以看<a href="https://gitlab.kitware.com/cmake/community/-/wikis/Home">cmake gitlab链接</a>。</p><p>CMake是一个是Build工具，负责可执行文件的构建</p><p>CTest是一个测试驱动工具，用于运行测试</p><p>CPack是一个打包工具，用于创建用特定平台用Cmake编译的软件安装包</p><p>CDash是一个Web应用，用于显示测试结果和执行在持续集成测试<a href="https://www.bookstack.cn/read/CMake-Cookbook/content-chapter14-14.2-chinese.md">参考</a></p><p>CMake是如何实现的</p><p>如前所述，CMake是一个元构建系统，可用于为许多其他构建工具创建构建文件.</p><p>使用cmake –help可以查看其生成器。</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220621211851381.png" alt="image-20220621211851381" style="zoom:67%;"><h2><span id="cmake处理过程">CMake处理过程</span></h2><p>CMake主要有两个阶段</p><ul><li><p>Configure CMake处理输入给它的一切，同时创建执行Build的内部表示</p></li><li><p>Generate 创建真正的编译文件</p></li></ul><h3><span id="cmake-configure步骤">CMake Configure步骤</span></h3><ol><li><p>检测CMakeCache.txt是否存在，如果存在就读取</p></li><li><p>读取源目录的根目录下的CMakeLists.txt文件，CMake语言解析器会去解析CMakeLists.txt文件。每一个文件中被发现的命令都会被执行，另外CMakeLists.txt文件可以通过CMake命令 <code>include</code>和  <code>add_subdirectory</code>触发解析。CMake会为每一个命令生成一个可以在CMake语言中使用的C++对象，例如<code>add_library</code> <code>if</code> <code>include</code> 等命令。其实CMake整个语言以命令调用的形式实现的。CMake的语言解析器就干了一件事情，就是把CMake输入的文件转换成命令的调用和这些命令需要的参数(字符串列表)。</p></li></ol><p>CMake其实就是将用户写的CMake语句进行执行，执行完了后在内存中就会生成文件(表示项目的构建)，这些文件中包含了库、可执行文件、自定义命令、选择generator需要的信息。这些都在CMakeCache.txt文件里面。</p><p>内存中的文件有所以需要构建的target(比如库、可执行文件)，用户也可以自定义target(用户可以定义他们的输入、输出、编写他们在运行时自定义的命令或脚本)。CMake把每一个target都保存到一个CmTarget对象中。</p><p>这些对象依次存放到cmMakefile对象中，也就是是在source tree的给定目录中找到的所有目标都会存储到这里。</p><p>总结就是，cmMakeifle包含了所有cmTarget目标。</p><h3><span id="cmake-generate步骤">CMake Generate步骤</span></h3><p>在configure步骤执行之后就可以执行gennerate步骤了。这个步骤就是使用用户指定的编译工具去得到编译的文件和目标产物。在这一步targets(库、可执行文件、用户自定义target)会被转换为IDE编译工具的输入或者是一系列的Makefiles(被make执行)。</p><p>CMake会自动构建依赖，对于generator是Makefiles的项目，Cmake会把项目依赖信息存放在以下四个文件</p><ul><li><p>depend.cmake 存储所有目标的依赖信息</p></li><li><p>flags.cmake 包含目标源文件的编译选项信息，被改变了就需要重新编译</p></li><li><p>build.cmake 编译这些依赖的规则</p></li><li><p>DependInfo.cmake 为了保持编译信息的是最新的，也包含项目这部分的文件，以及他们的语言是什么。当一个目标的依赖过时的时候，就会重新计算目标的依赖。</p></li></ul><p>后面如果想看懂make文件，就需要了解makefile的知识</p><h2><span id="举例">举例</span></h2><p>我有如下CMakeLists.txt</p><pre class=" language-Plain"><code class="language-Plain">cmake_minimum_required(VERSION 3.8)project(native)find_package(Boost CONFIG REQUIRED)message($&#123;Boost_VERSION&#125;)set(CMAKE_BUILD_TYPE Debug)set(CMAKE_MACOSX_RPATH 0)SET(CMAKE_CXX_FLAGS_DEBUG "$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb")add_library(testNative SHARED    common/seg.cc)add_executable($&#123;PROJECT_NAME&#125; main.cc)target_include_directories($&#123;PROJECT_NAME&#125; PUBLIC    ./common)target_link_libraries($&#123;PROJECT_NAME&#125; testNative)</code></pre><p>这时候创建build文件夹，执行cmake .. make之后得到如下表示</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)" alt="img" style="zoom:50%;"><p>打开其中一个target文件，结果如下</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20220621212024158.(null)" alt="img" style="zoom:50%;"><p>XXX.o.d文件包含了inclue文件的地址。</p><p>这时候添加一个test.h文件进去</p><p>报错</p><pre class=" language-Plain"><code class="language-Plain"> fatal error: 'test.h' file not found #include "test.h"</code></pre><p>发现是在编译</p><blockquote><p>[ 25%] Building CXX object CMakeFiles&#x2F;testNative.dir&#x2F;common&#x2F;seg.cc.o</p></blockquote><p>找到testNative目标，查看flags.make</p><pre class=" language-Plain"><code class="language-Plain"># CMAKE generated file: DO NOT EDIT!# Generated by "Unix Makefiles" Generator, CMake Version 3.22# compile CXX with /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++CXX_DEFINES = -DtestNative_EXPORTSCXX_INCLUDES = CXX_FLAGS =  -O0 -Wall -g -ggdb -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk -mmacosx-version-min=12.2 -fPIC</code></pre><p>发现确实没有include进去，这时候修改testNative在CMakeLists.txt的内容，使得包含该头文件。</p><p>重新编译查看testNative target下的flags.make</p><pre class=" language-Plain"><code class="language-Plain"># CMAKE generated file: DO NOT EDIT!# Generated by "Unix Makefiles" Generator, CMake Version 3.22# compile CXX with /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++CXX_DEFINES = -DtestNative_EXPORTSCXX_INCLUDES = -I/Users/bytedance/Documents/Code/C++/native/common/testCXX_FLAGS =  -O0 -Wall -g -ggdb -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk -mmacosx-version-min=12.2 -fPIC</code></pre><h2><span id="指定gennerator">指定gennerator</span></h2><p>我们这时候用的是默认的gennerator。我们可以指定gennerator比如Ninja</p><p>Cmake -G Ninja ..</p><p>Ninja</p><p>同样是编译出错，看一下CMakefiles</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20220621212030121.(null)" alt="img" style="zoom:50%;"><p>参考Ninja学习资料，主要是rule.ninja 和 build.ninja文件</p><p>其中rule.ninjaa定义了rule,也就是编译执行的命令</p><p>build.ninja 执行真正的build,会给rule中的命令提供输入与输出</p><p>查看ninja.build中对应target的写法，发现</p><blockquote><p>  INCLUDES &#x3D; -I&#x2F;Users&#x2F;bytedance&#x2F;Documents&#x2F;Code&#x2F;C++&#x2F;native&#x2F;.&#x2F;common</p></blockquote><p>确实没有头文件，添加之后</p><blockquote><p>  INCLUDES &#x3D; -I&#x2F;Users&#x2F;bytedance&#x2F;Documents&#x2F;Code&#x2F;C++&#x2F;native&#x2F;common&#x2F;test -I&#x2F;Users&#x2F;bytedance&#x2F;Documents&#x2F;Code&#x2F;C++&#x2F;native&#x2F;.&#x2F;common</p></blockquote><p>就包含在内，问题完美解决。所以一切的根源就是要充分理解问题，定位问题，再去查找问题原因，再解决。不然后面两步会浪费大量的时间与精力。</p><h2><span id="学习资料">学习资料</span></h2><p><a href="https://www.bookstack.cn/read/CMake-Cookbook/README.md">CMake菜谱</a></p><p><a href="http://www.aosabook.org/en/cmake.html#fig.cma.obj">how cmake work</a></p><ul><li><p><a href="https://ninja-build.org/manual.html">Ninja官方手册</a></p></li><li><p><a href="http://www.gnu.org/software/make/manual/make.html">GNU make官方文档</a></p></li><li><p><a href="https://github.com/ninja-build/ninja/wiki/List-of-generators-producing-ninja-build-files">List of generators producing ninja build files</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程认知</title>
      <link href="/2022/06/13/yu-yan/gong-cheng-ren-zhi/gong-cheng-ren-zhi/"/>
      <url>/2022/06/13/yu-yan/gong-cheng-ren-zhi/gong-cheng-ren-zhi/</url>
      
        <content type="html"><![CDATA[<h1><span id></span></h1><h2><span id="思维">思维</span></h2><ul><li><p>对于有关联的数据结构，最好组合在一起，形成类或者是结构体</p></li><li><p>在探索方案的时候，要做到一下几点</p></li></ul><ol><li>整理数据流程功能要走通</li><li>想好如何复用现有的代码，功能而不是自己重写</li><li>要学会提前设计好数据结构，不要没做好就弄，会浪费很多时间</li></ol><ul><li>遇到问题，先分段找到大致的范围， 之后先考虑可能的情况，然后依次排除可能性更高的情况</li></ul><h2><span id="代码">代码</span></h2><ul><li>在编写代码的初期，为了确保代码的准确性，可以适当的添加assert()，方便快速定位代码异常位置。之后再相应的删除代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码习惯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo使用教程</title>
      <link href="/2022/06/12/hexo-shi-yong-jiao-cheng/"/>
      <url>/2022/06/12/hexo-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1><span id="hexo使用教程">Hexo使用教程</span></h1><!-- ttoc --><h2><span id="创建与发布文章">创建与发布文章</span></h2><blockquote><p>hexo new 文章名</p><p>hexo deploy -g 部署</p></blockquote><h2><span id="删除文章">删除文章</span></h2><blockquote><p>直接在source&#x2F;_post文件目录下删除文章，再只想 hexo d -g</p></blockquote><h2><span id="theme更改">theme更改</span></h2><p>首先将自己喜欢的主题下载到theme目录下。</p><p>有两个设置，一个在hexo主目录下面，配置使用哪一个主题(theme字段)，theme目录下面有具体的主题文件，当中含有一个配置文件用于配置细节。</p><p><a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">主题推荐</a></p><p><a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-19">主题使用手册</a></p><h2><span id="安装依赖">安装依赖</span></h2><p>在 <code>hexo init</code>目录下只想 nmp install xxx –save进行安装</p><h2><span id="搭建">搭建</span></h2><ol><li>注册github账号</li><li>新建仓库，注意仓库的名称必须为 用户名.github.io</li><li>初始化仓库 hexo init 文件夹</li><li>hexo d -g 之后打开浏览器访问 用户名.git</li></ol><h3><span id="配置评论功能">配置评论功能</span></h3><p>使用valline配置评论功能。</p><ol><li>首先去valline官网注册一个账号。</li><li>应用中的设置中点击应用凭证，获取AppID AppKey</li><li>然后去_config.yaml上进行配置</li></ol><pre class=" language-c++"><code class="language-c++">valine:  enable: true # 设置为true，默认为false  appid:  # 将应用key的App ID设置在这里  appkey: # 将应用key的App Key设置在这里  notify: false# 邮箱通知 , https://github.com/xCss/Valine/wiki，默认为false  verify: false# 验证码 默认为false  placeholder: Just go go ^_^ # 初始化评论显示，根据自己修改，这里默认，  avatar: monsterid # 头像风格，默认为mm，可进入网址：https://valine.js.org/visitor.html查看头像设置，这里有许多头像风格，进行设置  guest_info: nick,mail,link # 自定义评论标题  pageSize: 10 # 分页大小，10页就自动分页  visitor: true # 是否允许游客评论 ，进入官网查看设置：https://valine.js.org/visitor.html</code></pre><p>最后效果如下：</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220610210620831.png" alt="image-20220610210620831" style="zoom:33%;"><p><a href="https://cloud.tencent.com/developer/article/1965154">更多配置</a></p><h2><span id="自定义域名">自定义域名</span></h2><p>可以花点钱去定义自己的域名，而不需要.github.io了</p><p>具体操作如下</p><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/124607458?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165486692316780366521224%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165486692316780366521224&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-124607458-null-null.142%5Ev13%5Econtrol,157%5Ev14%5Econtrol&utm_term=hexo%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&spm=1018.2226.3001.4187">域名自定义操作</a></p><h2><span id="写文章">写文章</span></h2><h3><span id="配置图床">配置图床</span></h3><p>picgo + 阿里云 + typora</p><p><a href="https://zhuanlan.zhihu.com/p/104152479">配置教程</a></p><h2><span id="插件推荐">插件推荐</span></h2><p>Hexo提供了诸多插件来增强博客体验，地址<code>http://hexo.io/plugins/</code>。</p><ul><li>hexo-toc</li></ul><p>用于生成目录，只需要在生成目录的地方写入 <code>&lt;!-- ttoc --&gt;</code></p><p>安装 <code>npm install hexo-toc --save</code></p><p>在博客根目录下的 <code>_config.yml</code> 中如下配置：</p><pre><code>toc:  maxDepth: 3</code></pre><p><a href="https://yscoder.github.io/20150514/hexo-toc.html">参考</a></p><h2><span id="hexo文档归类">hexo文档归类</span></h2><p>_config.yaml下面有两个配置</p><p><code>permalink</code> 用于设置文章的永久链接格式<br><code>new_post_name</code> 新文章的文件名称</p><p>配置如下命令，即可让新建的文章默认按照年月去分类。<br>在<code>_config.yml</code>文件中修改下面的命令<br><code>new_post_name: :year/:month/:title.md</code></p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5yeXpleWFuZy50b3AvMjAyMDA3MjYwOTI3MjQucG5n?x-oss-process=image/format,png" alt="20200726092724" style="zoom:50%;"><p>通过该命令 <code>hexo new post -p /后端/test.md</code> 执行后，会在post文件夹下创建子文件夹 “后端”，并创建一篇test.md博文。</p><p><a href="https://hexo.io/zh-cn/">hexo官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数返回优化</title>
      <link href="/2022/06/12/yu-yan/c/c-han-shu-fan-hui-you-hua/"/>
      <url>/2022/06/12/yu-yan/c/c-han-shu-fan-hui-you-hua/</url>
      
        <content type="html"><![CDATA[<h1><span id="c函数返回优化">C++函数返回优化</span></h1><p>我们知道，函数运行结束后，函数内部的局部变量就会消失，当函数返回的对象的时候，会产生一个临时对象，这样会消耗很多的计算资源，写一段代码进行测试。</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class MyBuff &#123; public:  MyBuff() &#123;    cout << "MyBuff()" << endl;  &#125;  MyBuff(const MyBuff& b) = delete;  MyBuff& operator=(const MyBuff& b) = delete;  ~MyBuff() &#123;    cout << "~MyBuff()" << endl;  &#125;  MyBuff(MyBuff&& b) noexcept &#123; cout << "move construct" << endl; &#125;  MyBuff& operator=(MyBuff&& b) noexcept &#123;    cout << "move assign " << endl;    return *this;  &#125;&#125;;class bbuffer &#123; public:  bbuffer() &#123;&#125;  void show() &#123; cout << "sh bbuffer" << endl; &#125;  ~bbuffer() &#123;&#125;&#125;;MyBuff GetBuff() &#123;  MyBuff res;  cout << &res << endl;  bbuffer b_;  b_.show();  return res;&#125;int main() &#123;  MyBuff b = GetBuff();  cout << &b << endl;&#125;</iostream></code></pre><p>执行结果如下：</p><pre><code>MyBuff()0x7ff7bb322258show bbuffer0x7ff7bb322258~MyBuff()</code></pre><p>是不是感觉和理解的不对，这时候好像并没有产生一个临时的对象，我们发现b和临时对象res的地址是一样的，并且res的析构是在整个程序结束的时候执行的，难道编译器进行了优化。</p><p>之后百度发现有一种优化叫做返回值优化机制，<a href="https://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html">传送门</a>，编译时候加入参数 -fno-elide-constructors优化。</p><p>从新执行代码结果如下</p><pre><code>MyBuff()0x7ff7b2e2a200show bbuffermove construct~MyBuff()move construct~MyBuff()0x7ff7b2e2a258~MyBuff()</code></pre><p>这时候</p><p>MyBuff()是在GetBuff()函数内部进行构造。</p><p>返回的时候生成临时变量，(函数的返回值为右值)触发一次移动构造，之后析构res.</p><p>之后临时变量用来构造main中的c，之后析构</p><p>函数执行完成，c被析构。</p><p>为什么没有调用移动赋值构造，<a href="https://www.jianshu.com/p/fb2440750f70">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大小端详解</title>
      <link href="/2022/06/12/yu-yan/c/da-xiao-duan/"/>
      <url>/2022/06/12/yu-yan/c/da-xiao-duan/</url>
      
        <content type="html"><![CDATA[<h1><span id="大小端详解">大小端详解</span></h1><p> [toc]</p><h2><span id="大小端原理">大小端原理</span></h2><p>大小端出现的原因在于：在计算机中，&#x3D;&#x3D;数据都是按照字节去进行存储的(所以如果是单字节的问题就不涉及到大小端)&#x3D;&#x3D;，但是对于多字节(int,long等)就会涉及到数据的存储顺序的问题，这也就出现了两种常见的存储方式</p><ul><li>Big endian : 大端存储，大端存储是高字节在前面(低地址)，低字节在后面(高地址)</li><li>Little endiam ：小端存储，小端存储是高字节在后面(高地址)，低字节在前面(低地址)</li></ul><p>不同的cpu可能有不同的模型</p><p>优点</p><ul><li>大端模式，由于高位在低地址，所以很容易判断正负</li><li>小端模式，强制抓换数据的时候，不需要调整字节内容</li></ul><p>以0x1234为例进行说明。</p><table><thead><tr><th>地址</th><th>0x4000（低地址）</th><th>0x4001（高地址）</th></tr></thead><tbody><tr><td>大端存储</td><td>0x12</td><td>0x34</td></tr><tr><td>小端存储</td><td>0x34</td><td>0x12</td></tr></tbody></table><h2><span id="大小端验证">大小端验证</span></h2><h3><span id="c验证">C++验证</span></h3><p>C++判断大小端可以借用Union，union在某种程度上和struct是一种数据结构</p><p>相同点</p><ul><li>都可以包含不同的数据类型和变量</li></ul><p>不同点</p><ul><li>struct是所有数据&#x3D;&#x3D;共存&#x3D;&#x3D;，有容乃大，不管struct内的数据结构用不用，都会为其分配内存</li><li>union是各种变量互斥的存在。其实就是共用一块内存地址。union的大小取决与里面内存对齐后最大的那个。</li></ul><p><a href="https://blog.csdn.net/ahelloyou/article/details/118488687?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165475505716782395384248%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165475505716782395384248&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-118488687-null-null.nonecase&utm_term=%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90&spm=1018.2226.3001.4450">内存对齐知识点</a></p><p>这时候就可以利用union去判断大小端。</p><pre class=" language-c++"><code class="language-c++">union U &#123;  char ch[4];  int var;&#125; test;这时候U的sizeof为4我们进行如下的赋值操作  test.ch[0] = 0x00u; // 低地址  test.ch[1] = 0x00u; // +    test.ch[2] = 0x00u; // +    test.ch[3] = 0x01u; // 高地址                                                            高位(32) -    -   低位(0)如果是大端模式，那么高位放到低地址为 0x00u 0x00u 0x00u 0x01u如果是小端模式，那么高位放在高地址为 0x01u 0x00u 0x00u 0x00u如果test.val == 1那么就是大端模式，反之就是小端。</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> c++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 464. 我能赢吗</title>
      <link href="/2022/06/12/yu-yan/leetcode/dfs/464-wo-neng-ying-ma/"/>
      <url>/2022/06/12/yu-yan/leetcode/dfs/464-wo-neng-ying-ma/</url>
      
        <content type="html"><![CDATA[<h4><span id="464-我能赢吗"></span></h4><p>难度中等370收藏分享切换为英文接收动态反馈</p><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 <code>1</code> 到 <code>10</code> 的任意整数，累计整数和，先使得累计整数和 <strong>达到或超过</strong> 100 的玩家，即为胜者。</p><p>如果我们将游戏规则改为 “玩家 <strong>不能</strong> 重复使用整数” 呢？</p><p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;&#x3D; 100。</p><p>给定两个整数 <code>maxChoosableInteger</code> （整数池中可选择的最大数）和 <code>desiredTotal</code>（累计和），若先出手的玩家是否能稳赢则返回 <code>true</code> ，否则返回 <code>false</code> 。假设两位玩家游戏时都表现 <strong>最佳</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：maxChoosableInteger = 10, desiredTotal = 11输出：false解释：无论第一个玩家选择哪个整数，他都会失败。第一个玩家可以选择从 1 到 10 的整数。如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：maxChoosableInteger = 10, desiredTotal = 0输出：true</code></pre><p><strong>示例 3:</strong></p><pre><code>输入：maxChoosableInteger = 10, desiredTotal = 1输出：true</code></pre><h3><span id="思路">思路</span></h3><p>首先想到的是暴力解法，也就就将每一种情况都遍历一遍。其实动态规划，也是在记忆dfs的基础上进行的，也就是其中一个是正向遍历(自顶向下)，一个是递归逆向的(自底向上)。</p><p>那么怎么去记忆化。也就是找到变量并将其记录下来，下次再次遇到的时候就可以直接得到结果。</p><p>这里的变量是，</p><ul><li>我们取的数和剩余的数(这里用二进制去表示取的数，因为m&lt;&#x3D;20,也就是20位，这样就可以用statae代表，而visited[state]记录着这个状态下的结果)</li><li>sum</li></ul><p>依照这个思路写下代码如下；</p><pre class=" language-c++"><code class="language-c++">class Solution &#123;private:    // visited[i] == 0，说明没有计算过    // visited[i] == 1，说明计算过，结果为 true    // visited[i] == 2，说明计算过，结果为 false    int visited[1 << 21];public:    bool canIWin(int maxChoosableInteger, int desiredTotal) &#123;        // 判断当前做选择的玩家（先手），是否一定赢        // 开始时，state = 0，表示「公共整数集」中的所有数字都未被使用过         if (maxChoosableInteger >= desiredTotal)            return true;        if (maxChoosableInteger * (maxChoosableInteger + 1) < 2*desiredTotal)            return false;        return dfs(0, 0, maxChoosableInteger, desiredTotal);    &#125;        // 当前做选择的玩家是否一定赢    bool dfs(int state, int sum, int maxChoosableInteger, int desiredTotal) &#123;        if (visited[state] == 1) return true;        if (visited[state] == 2) return false;        // 遍历可选择的公共整数        for (int x = 1; x <= maxchoosableinteger; ++x) &#123; 如果 x 已经被使用过了，则不能选择 if ((1 << x) & state) continue; 如果选择了 以后，大于等于了 desiredtotal，当前玩家赢 (sum +>= desiredTotal) &#123;                visited[state] = 1;                return true;            &#125;            // 当前玩家选择了 x 以后，判断对方玩家一定输吗？            if (!dfs((1 << x) | state, sum + x, maxChoosableInteger, desiredTotal)) &#123;                visited[state] = 1;                return true;            &#125;        &#125;        visited[state] = 2;        return false;    &#125;    &#125;;</=></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语句提取数据存入excel</title>
      <link href="/2022/06/12/yu-yan/python/python-jiao-ben/yu-ju-ti-qu-shu-ju-cun-ru-excel/"/>
      <url>/2022/06/12/yu-yan/python/python-jiao-ben/yu-ju-ti-qu-shu-ju-cun-ru-excel/</url>
      
        <content type="html"><![CDATA[<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">from</span> re <span class="token keyword">import</span> X<span class="token keyword">import</span> xlwt<span class="token keyword">import</span> xlrd<span class="token keyword">def</span> <span class="token function">calculate_average</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># print(lst)</span>    sum <span class="token operator">=</span> <span class="token number">0</span>    acc <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> val <span class="token keyword">in</span> lst<span class="token punctuation">:</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        sum <span class="token operator">+=</span> int<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        acc <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>acc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">return</span> sum<span class="token operator">/</span>acc<span class="token keyword">def</span> <span class="token function">find_num</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>    p_1 <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    raw_1 <span class="token operator">=</span> p_1<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>str<span class="token punctuation">)</span>    str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>raw_1<span class="token punctuation">)</span>    p_2 <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"[0-9]+"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> p_2<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">write_file</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>    book <span class="token operator">=</span> xlwt<span class="token punctuation">.</span>Workbook<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建Workbook，相当于创建Excel</span>    <span class="token comment" spellcheck="true"># 创建sheet，Sheet1为表的名字，cell_overwrite_ok为是否覆盖单元格</span>    sheet1 <span class="token operator">=</span> book<span class="token punctuation">.</span>add_sheet<span class="token punctuation">(</span>u<span class="token string">'Sheet1'</span><span class="token punctuation">,</span> cell_overwrite_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    row <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>val<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span>row<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        row <span class="token operator">=</span> row<span class="token operator">+</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># write average</span>    sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span>row<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"average"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span>row<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> calculate_average<span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    book<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'/Users/bytedance/Documents/csv_1.0.xls'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    key <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Lock"</span><span class="token punctuation">,</span> <span class="token string">"eglmake"</span><span class="token punctuation">,</span> <span class="token string">"draw"</span><span class="token punctuation">,</span> <span class="token string">"buf"</span><span class="token punctuation">,</span> <span class="token string">"render"</span><span class="token punctuation">,</span> <span class="token string">"all"</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'/Users/bytedance/Documents/csv_1.0.log'</span><span class="token punctuation">,</span> <span class="token string">'r+'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fd<span class="token punctuation">:</span>        val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># for i in range(len(key)):</span>        <span class="token comment" spellcheck="true"># val[i].append([])</span>        <span class="token comment" spellcheck="true"># val[i].pop()</span>        <span class="token keyword">for</span> text <span class="token keyword">in</span> fd<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># print(text)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                v <span class="token operator">=</span> find_num<span class="token punctuation">(</span>text<span class="token punctuation">,</span> key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">": [0-9]+"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># print(v)</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>        write_file<span class="token punctuation">(</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>post</title>
      <link href="/2022/06/10/yin-shi-pin-ji-chu/rtc/rtc-suan-fa-ji-chu/"/>
      <url>/2022/06/10/yin-shi-pin-ji-chu/rtc/rtc-suan-fa-ji-chu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/10/hello-world/"/>
      <url>/2022/06/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
