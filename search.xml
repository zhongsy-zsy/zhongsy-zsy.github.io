<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大小端详解</title>
      <link href="/2023/06/06/yu-yan/android/android-studio-yin-yong-di-san-fang-ku/"/>
      <url>/2023/06/06/yu-yan/android/android-studio-yin-yong-di-san-fang-ku/</url>
      
        <content type="html"><![CDATA[<h1><span id="android-studio引用第三方库的方式">Android Studio引用第三方库的方式</span></h1><h2><span id="前言">前言</span></h2><p>这里描述的第三方库文件格式指的是</p><ol><li>so</li><li>aar</li></ol><p>so库介绍一种方法</p><p>Aar介绍两种方法</p><h2><span id="导入aar">导入aar</span></h2><h3><span id="libs目录下导入">libs目录下导入</span></h3><p>将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码：</p><pre><code>flatDir &#123; dirs &#39;libs&#39;, &#39;../moduleName/libs&#39; &#125;</code></pre><p>注：将 moduleName 替换为你自己的 library module 的 name.</p><p>然后在 module 的 build.gradle 文件中添加依赖：</p><pre><code>implementation(name: &#39;aar包名&#39;, ext: &#39;aar&#39;)</code></pre><h3><span id="模块导入">模块导入</span></h3><p><a href="https://www.jianshu.com/p/41df494803e6">参考</a></p><p>这种方式的思路是，先把 aar 包放入一个单独的文件夹中，然后我们再依赖这个文件夹就可以了，这个文件夹你也可以理解成一个特殊的 module。</p><p>先在工程目录下新建一个文件夹（和 app 同级），然后将你的 aar 包放入 这个文件夹，然后再新建一个 build.gradle 文件，在这个文件中添加下面两句：</p><pre><code>configurations.maybeCreate(&quot;default&quot;)artifacts.add(&quot;default&quot;, file(&#39;aar包名.aar&#39;))</code></pre><p>然后在你需要依赖的 library module 的 build.gradle 文件中添加依赖：</p><pre><code>implementation project(&#39;:存放aar包的文件夹&#39;)</code></pre><p>最后需要在setting.gradle文件中加入</p><pre><code>include(&#39;:module&#39;)</code></pre><p><a href="https://docs.gradle.org/current/userguide/dependency_management.html">api参考</a></p><p>这里解释一下主要的几个点含义：</p><ol><li>implementation后面字符串含义</li></ol><blockquote><pre class=" language-arduino"><code class="language-arduino">implementation 'com.example.android:app-magic:12.3'</code></pre></blockquote><p>这是远程二进制依赖，这是一个简写，展开就是：</p><pre class=" language-csharp"><code class="language-csharp">implementation <span class="token keyword">group</span><span class="token punctuation">:</span> <span class="token string">'com.example.android'</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'app-magic'</span><span class="token punctuation">,</span> version<span class="token punctuation">:</span> <span class="token string">'12.3'</span></code></pre><h2><span id="导入so">导入so</span></h2><ol><li>在app目录下创建libs目录</li><li>建立CPU架构文件目录</li><li>将so放置到对应CPU架构</li></ol><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pa56Iif56yU6K6w,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom:33%;"><ol start="4"><li><p>在Module的build.gradle文件中添加</p><pre><code> sourceSets &#123;        main &#123;            jniLibs.srcDirs = [&quot;libs&quot;]         &#125;    &#125; //   jniLibs作用是告知AS, jniLibs资源所在的位置    packagingOptions &#123;        pickFirst &quot;*/armeabi-v7a/*.so&quot;        pickFirst &quot;*/arm64-v8a/*.so&quot;        pickFirst &quot;*/x86/*.so&quot;        pickFirst &quot;*/x86_64/*.so&quot;    &#125; // packagingOptions是java资源的选取选项，pickFirst代表的含义是遇到重复的首选获取文件列表</code></pre></li></ol><h2><span id="参考">参考</span></h2><p><a href="https://google.github.io/android-gradle-dsl/2.3/index.html">Android plugin DSL Reference</a></p>]]></content>
      
      
      <categories>
          
          <category> gradle </category>
          
          <category> android studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
            <tag> android studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频同步</title>
      <link href="/2022/12/02/yin-shi-pin-ji-chu/rtc/yin-shi-pin-tong-bu/yin-shi-pin-tong-bu/"/>
      <url>/2022/12/02/yin-shi-pin-ji-chu/rtc/yin-shi-pin-tong-bu/yin-shi-pin-tong-bu/</url>
      
        <content type="html"><![CDATA[<h1><span id="音视频同步">音视频同步</span></h1><h2><span id="音频系统概述">音频系统概述</span></h2><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null).png" alt="img"></p><ol><li><p>音频时延payload_delay_ms  jitter_delay(neteq)。</p></li><li><p>在WebRTC中有neteq，所以，音频的卡顿以及卡顿时长都是放在neteq内部进行计算的。</p></li></ol><h2><span id="时间戳">时间戳</span></h2><p>时间戳的概念主要有以下几个：</p><ul><li><p>ntp时间戳: NTP时间戳是绝对时间戳</p></li><li><p>本地时间戳</p></li><li><p>RTP时间戳：RTP时间戳是相对时间戳</p></li></ul><p><strong>ntp时间戳</strong></p><p>RTP的标准并没有规定音频、视频流的第一个包必须同时采集、发送，也就是说开始的一小段时间内可能只有音频或者视频，再加上可能的网络丢包，音频或者视频流的开始若干包可能丢失，那么不能简单认为接收端收到的第一个音频包和视频包是对齐的，需要一个共同的时间基准来做时间对齐，这就是NTP时间戳的作用。</p><p>NTP时间戳是从1900年1月1日00:00:00以来经过的秒数，发送端以一定的频率发送SR(Sender Report)这个RTCP包，分为视频SR和音频SR，SR包内包含一个RTP时间戳和对应的NTP时间戳，接收端收到后就可以确定某个流的RTP时间戳和NTP时间戳的对应关系，这样音频、视频的时间戳就可以统一到同一个时间基准下。</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20221202205556002.png" alt="img"></p><p>如上图，发送端的音视频流并没有对齐，但是周期地发送SR包，接收端得到音视频SR包的RTP时间戳、NTP时间戳后通过线性回归得到NTP时间戳Tntp和RTP时间戳Trtp时间戳的对应关系：</p><p>Tntp_audio &#x3D; f(Trtp_audio)</p><p>Tntp_video &#x3D; f(Trtp_video)</p><p>其中Tntp &#x3D; f(Trtp) &#x3D; kTrtp + b 为线性函数，这样接收端每收到一个RTP包，都可以将RTP时间戳换算成NTP时间戳，从而在同一时间基准下进行音视频同步。</p><p><strong>本地时间戳</strong></p><p>从系统启动启动开始计时。</p><p><strong>RTP****时间戳</strong></p><p>RTP时间戳定义了负载数据的采样时刻，描述的是负载数据的帧间顺序</p><blockquote><p>“The timestamp reflects the sampling instant of the first octet in the RTP data packet. The sampling instant must be derived from a clock that increments monotonically and linearly in time to allow synchronization and jitter calculations. The resolution of the clock must be sufficient for the desired synchronization accuracy and for measuring packet arrival jitter (one tick per video frame is typically not sufficient). ”</p></blockquote><p>也就是说，RTP时间戳是从单调线性递增的时钟里面获得的，时钟的精度由采样频率决定，视频的采样一般为90kZ，时间戳增加1，实际时间增加1&#x2F;90000s</p><p>等价于，本地时间增加1，采样的时间增加90000s。</p><p>在WebRTC内部，ntp时间的计算过程如下：</p><pre class=" language-C++"><code class="language-C++">// Capture time may come from clock with an offset and drift from clock_.int64_t capture_ntp_time_ms;if (video_frame.ntp_time_ms() > 0) &#123; //值为0，不会进入  capture_ntp_time_ms = video_frame.ntp_time_ms();&#125; else if (video_frame.render_time_ms() != 0) &#123;//render_time_ms由timestamp_us_换算过来，本地时间。在采集的时候已经赋值  capture_ntp_time_ms = video_frame.render_time_ms() + delta_ntp_internal_ms_;&#125; else &#123;  capture_ntp_time_ms = current_time_ms + delta_ntp_internal_ms_;&#125;incoming_frame.set_ntp_time_ms(capture_ntp_time_ms);delta_ntp_internal_ms_(clock_->CurrentNtpInMilliseconds() - clock_->TimeInMilliseconds())// Convert NTP time, in ms, to RTP timestamp.const int kMsToRtpTimestamp = 90;incoming_frame.set_timestamp(    kMsToRtpTimestamp * static_cast<uint32_t>(incoming_frame.ntp_time_ms()));</uint32_t></code></pre><p>重上述可以知道，ntp时间是从本地时间戳线性变化过来的，rtp时间戳是ntp时间戳线性变换过来的，所以ntp时间戳和rtp时间戳也存在线性变化的关系。ntp和本地时间戳本质上是一致的，只不过是在不同刻度下的表现。NTP时间和RTP时间戳是同一时刻的不同表示，区别在于精度不同。NTP时间是绝对时间，以毫秒为精度，而RTP时间戳则和媒体的采样频率有关。       </p><h2><span id="音视频目标">音视频目标</span></h2><p>不需要做到音视频绝对的同步，但是需要在一定的阈值内才能不被人所感知。</p><p>+ 代表声音比视频超前</p><p>(-100ms, +25ms) 无法感知</p><p>(-125ms, +45ms) 可以感知</p><p>(-, -185)U(+90, +) 影响体验</p><p>音频延迟于视频的阈值，相比于音频提前于视频的阈值更高。这个主要原因是人眼总是先看到光然后再听到声音，我们逐渐形成了这样的一个习惯。我们在理解信息的时候，也总是先视觉再听觉。如果声音先于视频较多，那么我们可能就无法将声音和画面对应上来，很容易感觉到音视频不同步。</p><h3><span id="不同步建模">不同步建模</span></h3><p>音视频不同步的根本原因在于，音视频的传输通过的是不同的数据流，不同数据流之间是独立传输与处理的，拥有独立的时间戳。在不做任何处理的情况下，各自处理的延迟差异也会导致不完全同步。</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20221202205752737-20221202211122185.png" alt="img"></p><p>如图所示，如果要处理音视频同步(同步的本质是，接收到数据后，根据数据能够计算出数据的需要的pts)。就需要处理好以下几个：</p><ul><li><p>获取接收端音视频数据绝对的ntp时间差。</p></li><li><p>获取发送端音视频采集绝对的NTP时间差。</p></li><li><p>音视频渲染缓冲时间delay。</p></li></ul><p>在webRTC中衡量音视频的不同步的统计量做syncdiff(含义：在不做同步的情况下，音视频不同步的情况)播放时间差 - 采集时间差。</p><p>不同步 &#x3D; 采集到接收组帧后的不同步 + JItterBuffer delay + 音视频渲染时长(渲染时长是计算再jitterbuffer的jitter中的，所以可以和JitterBuffer delay合并)</p><pre class=" language-C++"><code class="language-C++">// Calculate the difference between the lowest possible video delay and the  // current audio delay.  // 视频的jitter buffer当前延迟 -音频的jitter buffer当前延迟 + 相对延迟  int current_diff_ms =current_video_delay_ms - current_audio_delay_ms + relative_delay_ms;</code></pre><p>RelativeDelay相对时延，表示如下图所示：</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20221202205800266.png" alt="img"></p><p>相对时延 &#x3D; 接收时间差 - 采集时间差。</p><p>在webRTC中的rtp包中只能拿到rtp时间戳，但是接收端只能获取到接收端的本地时间戳，单位是ms，rtp的单位是采样步长，所以并不能直接使用，所以需要将rtp时间戳，转换成发送端为ms的单位，这时候就有了SR包，在接收端将数据包rtp时间戳映射为绝对的NTP时间戳。恰好RTCP SR的一个包里面有携带rtp timestamp和对应的NTP时间，SR包按照周期发送，接收端完全可以根据这些SR拟合出RTP timestamp和NTP timestamp的关系。这个转换由<code>RtpToNtpEstimator</code>完成。(这里其实并不关系发送时延)。</p><p>$$$$相对延迟 &#x3D; (视频帧接收时间 - 音频帧接收时间) - （视频帧采集时间- 音频帧采集时间） $$$$</p><p>可以看出，在webRTC中，都是将时间戳换算为发送端的NTP时间戳，再计算relativeDelay。</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20221202205805271.png" alt="img"></p><p>​ntp转ntp</p><h2><span id="音视频同步原理">音视频同步原理</span></h2><p>如果要做音视频同步，需要知道以下几个参数：</p><ul><li><p>音视频相对延迟</p></li><li><p>期望视频目标延迟，其实就是jitterbuffer里面计算出来的jitter</p></li><li><p>期望音频目标延迟</p></li></ul><p>有了上述的参数以后，剩下的就是同步策略：</p><p>• 如果视频相对音频存在播放延迟：如果视频已经存在延迟，减小视频播放延迟，通过快放追上音频；如果视频没有延迟，无法再降低，增加音频延迟，让音频慢放等待视频。</p><p>• 如果音频相对视频存在播放延迟：如果音频已经存在延迟，减小音频播放延迟，通过快放追上音频；如果音频没有延迟，无法再降低，增加视频延迟，让视频慢放等待音频。</p><pre class=" language-C++"><code class="language-C++">bool StreamSynchronization::ComputeDelays(int relative_delay_ms,                                          int current_audio_delay_ms,                                          int* total_audio_delay_target_ms,                                          int* total_video_delay_target_ms) &#123;  int current_video_delay_ms = *total_video_delay_target_ms;  RTC_LOG(LS_VERBOSE) << "Audio delay: " << current_audio_delay_ms                      << " current diff: " << relative_delay_ms                      << " for stream " << audio_stream_id_;  // Calculate the difference between the lowest possible video delay and the  // current audio delay.  int current_diff_ms =      current_video_delay_ms - current_audio_delay_ms + relative_delay_ms;// 1. 做平滑处理  avg_diff_ms_ =      ((kFilterLength - 1) * avg_diff_ms_ + current_diff_ms) / kFilterLength;  if (abs(avg_diff_ms_) < kMinDeltaMs) &#123;    // Don't adjust if the diff is within our margin.    return false;  &#125;  // Make sure we don't move too fast.  // 2.控制步长，单次不超过80ms  int diff_ms = avg_diff_ms_ / 2;  diff_ms = std::min(diff_ms, kMaxChangeMs);  diff_ms = std::max(diff_ms, -kMaxChangeMs);  // Reset the average after a move to prevent overshooting reaction.  avg_diff_ms_ = 0;  // 3. diff_ms大于0，代表的是视频落后音频，视频相对于音频有延迟  if (diff_ms > 0) &#123;    // The minimum video delay is longer than the current audio delay.    // We need to decrease extra video delay, or add extra audio delay.    // 视频已经有额外的延迟了，将视频的额外延迟减少，加快视频播放速度    if (video_delay_.extra_ms > base_target_delay_ms_) &#123;      // We have extra delay added to ViE. Reduce this delay before adding      // extra delay to VoE.      video_delay_.extra_ms -= diff_ms;      audio_delay_.extra_ms = base_target_delay_ms_;    &#125; else &#123;  // video_delay_.extra_ms > 0       // 没有额外延迟，增加音频的延迟，让音频等一下视频      // We have no extra video delay to remove, increase the audio delay.      audio_delay_.extra_ms += diff_ms;      video_delay_.extra_ms = base_target_delay_ms_;    &#125;  &#125; else &#123;  // if (diff_ms > 0)     // 4. diff_ms < 0代表视频超过音频，也就是音频相对于视频有延迟    // The video delay is lower than the current audio delay.    // We need to decrease extra audio delay, or add extra video delay.    // 音频为了音视频同步有额外延迟，降低低频延迟，此时diff_ms < 0    if (audio_delay_.extra_ms > base_target_delay_ms_) &#123;      // We have extra delay in VoiceEngine.      // Start with decreasing the voice delay.      // Note: diff_ms is negative; add the negative difference.      audio_delay_.extra_ms += diff_ms;      video_delay_.extra_ms = base_target_delay_ms_;    &#125; else &#123;  // audio_delay_.extra_ms > base_target_delay_ms_       // 如果音频没有额外延迟，增大视频言延迟，让视频等一下      // We have no extra delay in VoiceEngine, increase the video delay.      // Note: diff_ms is negative; subtract the negative difference.      video_delay_.extra_ms -= diff_ms;  // X - (-Y) = X + Y.      audio_delay_.extra_ms = base_target_delay_ms_;    &#125;  &#125;  // Make sure that video is never below our target.  video_delay_.extra_ms =      std::max(video_delay_.extra_ms, base_target_delay_ms_);  int new_video_delay_ms;  if (video_delay_.extra_ms > base_target_delay_ms_) &#123;    new_video_delay_ms = video_delay_.extra_ms;  &#125; else &#123;    // No change to the extra video delay. We are changing audio and we only    // allow to change one at the time.    new_video_delay_ms = video_delay_.last_ms;  &#125;  // Make sure that we don't go below the extra video delay.  new_video_delay_ms = std::max(new_video_delay_ms, video_delay_.extra_ms);  // Verify we don't go above the maximum allowed video delay.  new_video_delay_ms =      std::min(new_video_delay_ms, base_target_delay_ms_ + kMaxDeltaDelayMs);  int new_audio_delay_ms;  if (audio_delay_.extra_ms > base_target_delay_ms_) &#123;    new_audio_delay_ms = audio_delay_.extra_ms;  &#125; else &#123;    // No change to the audio delay. We are changing video and we only allow to    // change one at the time.    new_audio_delay_ms = audio_delay_.last_ms;  &#125;  // Make sure that we don't go below the extra audio delay.  new_audio_delay_ms = std::max(new_audio_delay_ms, audio_delay_.extra_ms);  // Verify we don't go above the maximum allowed audio delay.  new_audio_delay_ms =      std::min(new_audio_delay_ms, base_target_delay_ms_ + kMaxDeltaDelayMs);  video_delay_.last_ms = new_video_delay_ms;  audio_delay_.last_ms = new_audio_delay_ms;  RTC_LOG(LS_VERBOSE) << "Sync video delay " << new_video_delay_ms                      << " for video stream " << video_stream_id_                      << " and audio delay " << audio_delay_.extra_ms                      << " for audio stream " << audio_stream_id_;  *total_video_delay_target_ms = new_video_delay_ms;  *total_audio_delay_target_ms = new_audio_delay_ms;  return true;&#125;</code></pre><p>这里的extra_ms一开始是0，过程中会慢慢收敛。extra_ms的含义是音视频同步到底增加了多少的延迟，这里会不断累计，通过音画同步引入的“额外”延迟最终还需要恢复。extra_ms的作用在于此。</p><p>base_target_delay_ms_是基准，默认为0.</p><p>最后将目标延迟设置进入jitterbuffer</p><pre class=" language-C++"><code class="language-C++">  if (!syncable_audio_->SetMinimumPlayoutDelay(target_audio_delay_ms)) &#123;    sync_->ReduceAudioDelay();  &#125;  if (!syncable_video_->SetMinimumPlayoutDelay(target_video_delay_ms)) &#123;    sync_->ReduceVideoDelay();  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 多媒体技术 </category>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake 变量Scope</title>
      <link href="/2022/08/17/yu-yan/cmake/cmake-bian-liang-ke-jian-xing/"/>
      <url>/2022/08/17/yu-yan/cmake/cmake-bian-liang-ke-jian-xing/</url>
      
        <content type="html"><![CDATA[<h1><span id="cmake变量可见性">CMake变量可见性</span></h1><p>变量是CMake的基本存储单元，与别的语言的变量在理解上别无二致。CMake变量名大小写敏感，通常与数字、字母、_、-构成。</p><p>但是不同的是需要注意CMake变量的作用域。</p><p>主要有以下几个作用域</p><ul><li>目录作用域</li><li>文件作用域</li><li>函数作用域</li><li>Persistent Cache</li></ul><h2><span id="add_subdirector-vs-include"><strong>add_subdirector vs include</strong></span></h2><p>假设有以下CMake Project </p><pre><code>CMake_Test|__Child| |_ CMakeLists.txt|_ CMakeLists.txt</code></pre><p>其中CMake_Test目录中的CMakeLists.txt文件内容如下：</p><pre class=" language-cmake"><code class="language-cmake"># parent CMakeLists.txtcmake_minimum_required(VERSION 3.2)project(Test_CMake)set(A "parent")add_subdirectory(child)message("Parent A val $&#123;A&#125;")</code></pre><p>child中的CMakeLists.txt</p><pre class=" language-cmake"><code class="language-cmake"># child CMakeLists.txtset(A "child")message("Child A val $&#123;A&#125;")</code></pre><p>输出</p><pre><code>Child A val childParent A val parent</code></pre><p>发现子目录的变量只会作用与自身并不会影响Parent目录。是什么原因？</p><p>实际上是<code>add_subdirectory</code>命令；在<code>add_subdirectory</code>被执行的时候，会创建一块独立的区域去执行子目录的CMakeLists.txt文件，同时会拷贝一份A的变量去独立区域，大概的示意图如下：</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/1*jGGvhYHJNEJxT7zD63icXA.png" alt="img"></p><p>如图所以，Child中是Parent的副本。</p><p>改变CMakeLists.txt</p><pre class=" language-cmake"><code class="language-cmake"># parent CMakeLists.txtcmake_minimum_required(VERSION 3.2)project(Test_CMake)add_subdirectory(child)set(A "parent")message("Parent A val $&#123;A&#125;")</code></pre><p>输出</p><pre><code>Child A val Parent A val parent</code></pre><p>得出结论 &#x3D;&#x3D;<code>add_subdirectory</code>只会对之前可见的变量做拷贝&#x3D;&#x3D;</p><p>现在改变Parent CMakeLists.txt的内容</p><pre class=" language-cmake"><code class="language-cmake"># parent CMakeLists.txtcmake_minimum_required(VERSION 3.2)project(Test_CMake)set(A "parent")include(child)message("Parent A val $&#123;A&#125;")</code></pre><p>执行结果如下：</p><pre><code>Child A val childParent A val child</code></pre><p>与<code>add_subdirectory</code>相反<code>include</code>使得child与parent的scope一致，所以当我们include中set的时候会直接影响parent的值。</p><p>可以简单的理解为&#x3D;&#x3D;add_subdirectory&#x3D;&#x3D;是C++中的传值调用，&#x3D;&#x3D;include&#x3D;&#x3D;是C++中的传引用(指针)调用</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/1*0PRBYJVoj81eHQwkxj1ikA.png" alt="img"></p><p>那么如果是使用<code>add_subdirectory</code>那么如何在child中改变parent的值，实现如下：</p><pre class=" language-cmake"><code class="language-cmake"># child CMakeLists.txtset(A "child" PARENT_SCOPE)message("Child A val $&#123;A&#125;")</code></pre><p>输出</p><pre><code>Child A val parentParent A val child</code></pre><p>简单理解：</p><p>加入<code>PARENT_SCOPE</code>会直接修改parent目录下Ade值，但是并不会对当前目录下的copy A’进行修改</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/1*GDB14MRwLsZOWH6m0lcPBg.png" alt="img"></p><p>这时候可以看出<code>add_subdirectory</code>的时候是目录作用域，每个目录下的CMakeLists.txt是隔离的。</p><p><code>include</code>时候是文件作用域，都作用在parent CmakeLists</p><h2><span id="macro-vs-function">Macro vs Function</span></h2><pre class=" language-cmake"><code class="language-cmake"># parent CMakeLists.txtcmake_minimum_required(VERSION 3.2)project(Test_CMake)function(fun)    set(A "fuc A")endfunction()set(A "parent")fun()# include(child/CMakeLists.txt)add_subdirectory(child)message("Parent A val $&#123;A&#125;")</code></pre><p>输出</p><pre><code>Child A val parentParent A val child</code></pre><p>说明这时候function中<code>set</code>的变量就好像是&#x3D;&#x3D;函数定义的局部变量不会影响到外部&#x3D;&#x3D;</p><p>如果是传值呢？？？？</p><pre class=" language-cmake"><code class="language-cmake"># parent CMakeLists.txtcmake_minimum_required(VERSION 3.2)project(Test_CMake)function(fun param)    set($&#123;param&#125; "fuc A")endfunction()set(A "parent")fun(A)# include(child/CMakeLists.txt)add_subdirectory(child)message("Parent A val $&#123;A&#125;")</code></pre><p>输出</p><pre><code>Child A val parentParent A val child</code></pre><p>就算是传值也是copy传递的。</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/1*5T8b5u0KVPEZZfxDPFFpAA.png" alt="img"></p><p><strong>使用macro代替function</strong></p><pre class=" language-cmake"><code class="language-cmake"># parent CMakeLists.txtcmake_minimum_required(VERSION 3.2)project(Test_CMake)function(fun param)    set($&#123;param&#125; "fuc A")endfunction()macro(funmacro param)    set(A "macro fun")endmacro()set(A "parent")# fun(A)funmacro(A)# include(child/CMakeLists.txt)add_subdirectory(child)message("Parent A val $&#123;A&#125;")</code></pre><p>输出</p><pre><code>Child A val childParent A val macro fun-- Configuring done-- Generating done</code></pre><p>如果改为传参模式</p><pre class=" language-cmake"><code class="language-cmake">        # parent CMakeLists.txtcmake_minimum_required(VERSION 3.2)project(Test_CMake)function(fun param)    set($&#123;param&#125; "fuc A")endfunction()macro(funmacro param)    set($&#123;param&#125; "macro fun")    message("param $&#123;param&#125;")endmacro()set(A "parent")# fun(A)funmacro(A)# include(child/CMakeLists.txt)add_subdirectory(child)message("Parent A val $&#123;A&#125;")</code></pre><p>输出</p><pre><code>param AChild A val childParent A val macro fun</code></pre><p>通过结果可知，macro与include类似，与Parent工作在同一空间之中。</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/1*TALyVZ80_Xq3S9CXwMhrZw.png" alt="img"></p><p>如果想要在<code>add_subdirectory</code>中定义函数改变Parent中的值，就需要在set中加入<code>PARENT_SCOPE</code>。</p><p>也就是说function与macro，前者是函数作用域后者是文件作用域。</p><h2><span id="persistent-cache">Persistent Cache</span></h2><p>缓存变量，拥有着独立的scope，只能通过特定的请求改变其值，比如<code>set</code>,<code>uset</code>的时候带上<code>Cache</code>选项。Cache变量在整个CMake工程的编译声明周期中都有效。工程中任意的目录都可以访问Cache变量，&#x3D;&#x3D;类似于全局静态变量&#x3D;&#x3D;。&#x3D;&#x3D;需要注意的是，CMake是从上到下进行解析CMakeLists,tx文件的。&#x3D;&#x3D;</p><blockquote><p>set(cache_var1 “persistent-缓存变量1” CACHE STRING “abc”) </p></blockquote><p>编译后，可以在bulid&#x2F;CMakeCache.txt中看到该变量</p><h2><span id="参考">参考</span></h2><p><a href="https://blog.csdn.net/weixin_43708622/article/details/108315184">cmake-变量作用域</a></p><p><a href="https://levelup.gitconnected.com/cmake-variable-scope-f062833581b7">CMake Variable Scope</a></p><h2><span id="更多内容">更多内容</span></h2><p><a href="https://zhongsy-zsy.github.io/">更多内容</a></p>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 768. 最多能完成排序的块 II</title>
      <link href="/2022/08/12/yu-yan/leetcode/mei-ri-yi-ti/dan-diao-zhan/leetcode768-zui-duo-neng-wan-cheng-pai-xu-de-kuai/"/>
      <url>/2022/08/12/yu-yan/leetcode/mei-ri-yi-ti/dan-diao-zhan/leetcode768-zui-duo-neng-wan-cheng-pai-xu-de-kuai/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a></p><p>难度困难185收藏分享切换为英文接收动态反馈</p><p><em>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为<code>2000</code>，其中的元素最大为<code>10**8</code>。</em></p><p><code>arr</code>是一个可能包含<strong>重复元素</strong>的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p><p>我们最多能将数组分成多少块？</p><p><strong>示例 1:</strong></p><pre><code>输入: arr = [5,4,3,2,1]输出: 1解释:将数组分成2块或者更多块，都无法得到所需的结果。例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 </code></pre><p><strong>示例 2:</strong></p><pre><code>输入: arr = [2,1,3,4,4]输出: 4解释:我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 </code></pre><p><strong>注意:</strong></p><ul><li><code>arr</code>的长度在<code>[1, 2000]</code>之间。</li><li><code>arr[i]</code>的大小在<code>[0, 10**8]</code>之间。</li></ul><h2><span id="解析">解析</span></h2><p>根据题目的意思可能明确知道，尽量分块使得最后能分块的个数最多。是一个最值问题，那么就可以使用贪心算法，也就是使得每一个分块的窗口最小。</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220813153547212.png" alt="image-20220813153547212" style="zoom:50%;"><p>其实每一次窗口的左边界是确定的(上一次的右边界值)，代表的是左闭右开，我们需要确定的是最小的右边界。</p><p>这时候通过模拟发现:</p><blockquote><p>某一段能否成为区间是取决于后面的元素，也就是说，区间后面的元素都要 &lt;&#x3D; 区间内的最大值</p></blockquote><pre class=" language-c++"><code class="language-c++">/*    加入可能不能分块的情况，也就是说，分块的排序最后与整体的排序一致    设计数据结构    std:::map<std::set<int>> data    第一层索引代表的是数字    第二层索引代表的是位置*/#include <vector>#include <map>#include <set>#include <iostream>class Solution &#123;public:    int maxChunksToSorted(std::vector<int>& arr) &#123;        int result = 0;        int left = 0;        int right = 0;        int max_val;        while(left < arr.size()) &#123;            int index_val = arr[right];            // 查看后面是否有比自己更小的值            max_val = index_val;  // max_val代表当前区间内的最大值            int tmp_max = max_val;            // 后面有没有比区间内最大值更小的值了            for(int i = right + 1; i < arr.size(); ++i) &#123;                int val = arr[i];                if(val < max_val) &#123; // 扩大区间                    left = i;                    max_val = tmp_max;                    tmp_max = max_val;                &#125; else &#123;                    tmp_max = tmp_max>val? tmp_max : val;                &#125;            &#125;            left = left + 1;            right = left;            result++;        &#125;        return result;    &#125;    void BuildIndex(std::map<int, std::set<int> >& data, std::vector<int>& arr) &#123;                for(int i = 0; i <  arr.size(); ++i) &#123;            data[arr[i]].insert(i);        &#125;    &#125;&#125;;</int></int,></int></iostream></set></map></vector></std::set<int></code></pre><p>由于处理结果取决与后面元素的分布情况，适用于栈的处理方式</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220813164204130.png" alt="image-20220813164204130"></p><p>栈内每一个色块代表的是可能成为的一个组，值代表组内的最大值；当后面有值小于当前的最大值的时候就需要合并。最终的思想就是后面的元素都大于等于当前块内的最大值。</p><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    stack<int> _st;    int maxChunksToSorted(vector<int>& arr) &#123;        for(auto& val : arr) &#123;            if(_st.empty()) &#123;                _st.push(val);            &#125; else &#123;                if(_st.top() <= val) &#123; _st.push(val); &#125; else if(_st.empty()) continue; int tmp_max="_st.top();" while(!_st.empty() && _st.top()> val) &#123;                        _st.pop();                    &#125;                    // 更新最大值                    _st.push(tmp_max);                &#125;            &#125;        &#125;        return _st.size();    &#125;&#125;;</=></int></int></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简历制作</title>
      <link href="/2022/07/19/mian-shi/jian-li-zhi-zuo/"/>
      <url>/2022/07/19/mian-shi/jian-li-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<h2><span id="简历内容">简历内容</span></h2><ol><li>个人信息</li><li>教育经历</li><li>实习经历</li><li>项目经历</li><li>专业技能</li><li>其他</li></ol><p>&#x3D;&#x3D;所有的尽量写在一页上，实习经历，专业技能，项目经历要占到2&#x2F;3，排版简洁，不要花里胡哨&#x3D;&#x3D;</p><h3><span id="个人信息">个人信息</span></h3><p>联系方式很重要，一般要两个，一个手机号一个邮箱，照片可有可无(可以不用放)</p><p>常见问题：个人信息占比太大，民族，党员不用写，<code> github</code> <code>csdn</code>地址可以放在最后</p><h3><span id="教育经历">教育经历</span></h3><p>专业排名，成绩排名(没有太好就不要写)，顺序就是先写最近的再写本科的经历，不是重要的信息就简化，&#x3D;&#x3D;注意TOP 20%代表专业排名还是成绩排名&#x3D;&#x3D;</p><h3><span id="实习经历">实习经历</span></h3><p>实习的时间，职位，工作</p><p>工作要简短指标化，<code>STAR法则</code>&#x3D;&#x3D;情景，任务，行动，结果&#x3D;&#x3D; 。用指标去量化他，性能提升多少等等。体现出学到的内容以及某些方面的提升</p><h3><span id="项目经历">项目经历</span></h3><p>把重点的放在最前面，&#x3D;&#x3D;写进去的一定要懂、要明白，含金量高的放在第一位&#x3D;&#x3D;</p><p>&#x3D;&#x3D;面试官一般会要求有别的东西，有没有扩展，小项目也可以写，<font color="red">一定要体现出,根据自己的爱好去学习这个项目，从在这个项目中学到了什么东西，能力的提升</font>，项目不用太多一个到三个&#x3D;&#x3D;</p><p>主要有以下三个内容</p><ol><li>项目背景(一句话说完)</li><li>简述负责的内容(要贯穿知识点，比如使用XXX技术，解决了XXX)</li><li>使用到的技术栈，遇到的问题，怎么解决，最终达到什么效果(具体化)，例如：&#x3D;&#x3D;原来使用select io复用3000 后面使用epoll达到10000&#x3D;&#x3D;</li></ol><pre><code>要有对比，说明优劣，最后得出结论要思考有没有可以优化的地方，以后的改进方向面试官是很喜欢有扩展的定西</code></pre><p>&#x3D;&#x3D;特别注意要分点进行解答，比如1. 2. 3.&#x3D;&#x3D;</p><p>举例</p><pre class=" language-c++"><code class="language-c++">项目描述： 一个用于XXX系统，支持多设备管理，整个系统主要由XX系统，XX系统，XX系统，XX系统组合而成。最终实现XXX涉及技术: Linux OpenCV Cmake C/C++ Ros  Yolo Pytorch Cuda MarkDown- 使用JSON文件格式进行系统参数配置。- 使用外观者设计模式管理四个子系统，完善代码架构。- 使用线程池技术，充分利用多核性能，采用生产者-消费者模型进行数据处理使系统障碍物检测达28FPS。- 使用OpenCV对深度图像进行处理，XXX普通障碍物检测系统。- 使用智能指针，同时使用RAII手法，自动获取释放资源。- 使用Pytorch语言采用Ghost框架训练二分类模型，使用YoloV5框架训练XXX。- 使用TensorRT进行加速部署到Nano开发板上。- 使用MarkDown进行相关测试和说明文档的书写。</code></pre><h3><span id="专业技能">专业技能</span></h3><p>要进行适当的的扩展，要注意用词，自己不熟悉的千万不要写熟悉</p><pre><code>基础-&gt;进阶-&gt;高阶了解-&gt;熟练-&gt;掌握(熟练掌握)</code></pre><p>&#x3D;&#x3D;写到简历一定要会&#x3D;&#x3D;，不要泛泛而谈，要简单扩展。</p><p>在一个范围内的，不要都写出来，留一两个，防止面试官拓展。</p><p>eg，熟悉排序算法，快排、堆排序、希尔排序。(别的排序也要知道，但是不用都写出来，留几个)</p><p>&#x3D;&#x3D;写5-8条，不要太多&#x3D;&#x3D;</p><h3><span id="其他">其他</span></h3><p>不要千篇一律写自己，热爱学习，吃苦耐劳。这些别人跟你不了解根本不会去看的。你应该体现出你的习惯适合这份工作。自己是一个成长型人才。</p><p>eg</p><ol><li>写英语等级。</li><li>贴上博客地址，多少原创文章，多少阅读量以及多少排名</li><li>自己阅读过多少技术书籍，喜欢定期总结反思。</li></ol><p>最后，一定要复查简历，确保无错别字。同时，准备多份简历，在投递岗位的时候，要充分阅读JD并及时调整简历内容，使自己更加匹配岗位。</p><h3><span id="示例">示例</span></h3><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220719124605027.png" alt="image-20220719124605027" style="zoom:50%;"><h2><span id><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220719124358966.png" alt="image-20220719124358966"></span></h2><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220719124437087.png" alt="image-20220719124437087" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 2022第297周周赛</title>
      <link href="/2022/06/25/yu-yan/leetcode/zhou-sai/2022-di-28-zhou-zhou-sai/"/>
      <url>/2022/06/25/yu-yan/leetcode/zhou-sai/2022-di-28-zhou-zhou-sai/</url>
      
        <content type="html"><![CDATA[<h1><span id="2022-第297周周赛">2022 第297周周赛</span></h1><p>[toc]</p><h2><span id="2303-计算应缴税款总额"></span></h2><p>难度简单5收藏分享切换为英文接收动态反馈</p><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10-5</code> 的结果将被视作正确答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：brackets = [[3,50],[7,10],[12,25]], income = 10输出：2.65000解释：前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：brackets = [[1,0],[4,25],[5,50]], income = 2输出：0.25000解释：前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。需要支付的税款总计 $0 + $0.25 = $0.25 。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：brackets = [[2,50]], income = 0输出：0.00000解释：没有收入，无需纳税，需要支付的税款总计 $0 。</code></pre><p>解题，就是简单的模拟，并没有太多的技巧。主要训练思维逻辑</p><ol><li>如果没有超过uper,那么剩余部分按照该汇率</li><li>如果超过，超过部分另算，中间区间部分按照该汇率</li></ol><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    double calculateTax(vector<vector<int>>& brackets, int income) &#123;        double res = 0;        int remain = income;        for(int i=0;i<brackets.size();i++) &#123; int uper="brackets[i][0];" percentage="brackets[i][1];" if(income>= uper) &#123;                if(i==0) &#123;                    res += (uper*percentage)/100.0;                    remain -= uper;                &#125; else &#123;                    res += (uper - brackets[i-1][0])*percentage/100.0;                    remain -= uper-brackets[i-1][0];                &#125;            &#125; else &#123;                res += remain*percentage/100.0;                break;            &#125;        &#125;        return res;    &#125;&#125;;</brackets.size();i++)></vector<int></code></pre><h2><span id="2304-网格中的最小路径代价"></span></h2><p>难度中等12收藏分享切换为英文接收动态反馈</p><p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, …, <code>(x + 1, n - 1)</code> 中的任何一个单元格。<strong>注意：</strong> 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p><p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价<em>。</em></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png" alt="img"></p><pre><code>输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]输出：17解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。- 路径途经单元格值之和 5 + 0 + 1 = 6 。- 从 5 移动到 0 的代价为 3 。- 从 0 移动到 1 的代价为 8 。路径总代价为 6 + 3 + 8 = 17 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]输出：6解释：最小代价的路径是 2 -&gt; 3 。 - 路径途经单元格值之和 2 + 3 = 5 。 - 从 2 移动到 3 的代价为 1 。 路径总代价为 5 + 1 = 6 。</code></pre><p>这个个选择问题：</p><p>首先暴力解法，就不不断的选择，然后选取最小的结果，当然可以剪枝。</p><p>我们可以自底向上，也就是动态规划</p><p>dp[i][j]表示到达 （i，j）的最小代价，之后就可以根据这个含义去进行递推</p><pre><code>class Solution &#123;public:    int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; moveCost) &#123;        // 动态规划 dp[i][j] 代表到达i，j位置的最小代价        vector&lt;vector&lt;int&gt;&gt; dp(grid.size(), vector&lt;int&gt;(grid[0].size() , 0));        for(int i=0; i&lt;grid[0].size();i++) &#123;            dp[0][i] = grid[0][i];        &#125;        for(int i=1; i&lt;grid.size();i++) &#123;            for(int j=0; j&lt;grid[0].size(); j++) &#123;                for(int k=0; k&lt;grid[0].size(); k++) &#123;                    int lastVal = grid[i-1][k];                    int nowVal = grid[i][j];                    int cost = dp[i-1][k] + moveCost[lastVal][j] + nowVal;                    dp[i][j] = dp[i][j] == 0 ? cost : min(dp[i][j], cost);                &#125;            &#125;        &#125;        int minVal = dp[grid.size()-1][0];        for(int i=0;i&lt;grid[0].size();i++) &#123;            minVal = min(minVal, dp[grid.size()-1][i]);        &#125;        return minVal;            &#125;&#125;;</code></pre><h2><span id="2305-公平分发饼干"></span></h2><p>难度中等25收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p><p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p><p>返回所有分发的最小不公平程度。</p><p><strong>示例 1：</strong></p><pre><code>输入：cookies = [8,15,10,20,8], k = 2输出：31解释：一种最优方案是 [8,15,8] 和 [10,20] 。- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。分发的不公平程度为 max(31,30) = 31 。可以证明不存在不公平程度小于 31 的分发方案。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：cookies = [6,1,3,2,2,4,1,2], k = 3输出：7解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 - 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。分发的不公平程度为 max(7,7,7) = 7 。可以证明不存在不公平程度小于 7 的分发方案。</code></pre><p>解法： 暴力加剪枝，就是通过不断的分配求解出所有的组合，在选出最优组合</p><pre class=" language-c++"><code class="language-c++">class Solution &#123;public:    // 分发饼干    // 1. 所有零食包必须分发，同一个零食包中的所有饼干只能发给一个好走     // 返回最小的不公平程度，其实就是两包尽可能的平均    // 其实也可以变为一个背包问题    int minVal = INT_MAX;    int distributeCookies(vector<int>& cookies, int k) &#123;        queue<int> que;        for(auto v : cookies) &#123;            que.push(v);        &#125;           vector<int> money(k,0);        backtrack(money,que);        return minVal;    &#125;    void backtrack(vector<int>& money, queue<int>& cookies) &#123;        if(cookies.empty()) &#123;            int val = *max_element(money.begin(),money.end());            minVal = min(val, minVal);            return;        &#125;        int v = cookies.front();        cookies.pop();        for(int i=0; i< money.size();i++) &#123;            money[i] += v;            if(money[i] > minVal) &#123;                money[i] -= v;                continue;            &#125;            backtrack(money,cookies);            money[i] -= v;        &#125;        cookies.push(v);    &#125; &#125;;</int></int></int></int></int></code></pre><h2><span id="2306-公司命名"></span></h2><p>难度困难29收藏分享切换为英文接收动态反馈</p><p>给你一个字符串数组 <code>ideas</code> 表示在公司命名过程中使用的名字列表。公司命名流程如下：</p><ol><li>从 <code>ideas</code> 中选择 2 个 <strong>不同</strong> 名字，称为 <code>ideaA</code> 和 <code>ideaB</code> 。</li><li>交换 <code>ideaA</code> 和 <code>ideaB</code> 的首字母。</li><li>如果得到的两个新名字 <strong>都</strong> 不在 <code>ideas</code> 中，那么 <code>ideaA ideaB</code>（<strong>串联</strong> <code>ideaA</code> 和 <code>ideaB</code> ，中间用一个空格分隔）是一个有效的公司名字。</li><li>否则，不是一个有效的名字。</li></ol><p>返回 <strong>不同</strong> 且有效的公司名字的数目。</p><p><strong>示例 1：</strong></p><pre><code>输入：ideas = [&quot;coffee&quot;,&quot;donuts&quot;,&quot;time&quot;,&quot;toffee&quot;]输出：6解释：下面列出一些有效的选择方案：- (&quot;coffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee conuts&quot; 。- (&quot;donuts&quot;, &quot;coffee&quot;)：对应的公司名字是 &quot;conuts doffee&quot; 。- (&quot;donuts&quot;, &quot;time&quot;)：对应的公司名字是 &quot;tonuts dime&quot; 。- (&quot;donuts&quot;, &quot;toffee&quot;)：对应的公司名字是 &quot;tonuts doffee&quot; 。- (&quot;time&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;dime tonuts&quot; 。- (&quot;toffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee tonuts&quot; 。因此，总共有 6 个不同的公司名字。下面列出一些无效的选择方案：- (&quot;coffee&quot;, &quot;time&quot;)：在原数组中存在交换后形成的名字 &quot;toffee&quot; 。- (&quot;time&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。- (&quot;coffee&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：ideas = [&quot;lack&quot;,&quot;back&quot;]输出：0解释：不存在有效的选择方案。因此，返回 0 。</code></pre><p>关键是这样的。</p><p>设置pre[i][j] 代表的含义就是，将首字母i变为j后不在队列中的idea个数</p><p>这时候就知道，如果pre[j][i] 代表的是将首字母从j变成i后不在队列的idea的个数</p><p>含义就是 axx 与 bxxx相互交换首字母后都不在队列里面。</p><pre><code>using ll = long long;class Solution &#123;public:    long long distinctNames(vector&lt;string&gt;&amp; ideas) &#123;        unordered_set&lt;string&gt; s(ideas.begin(), ideas.end());        vector&lt;vector&lt;ll&gt;&gt; cnt(26, vector&lt;ll&gt;(26));        for(string&amp; is : ideas)&#123;            int pre = is[0] - &#39;a&#39;;            for(int i = 0; i &lt; 26; ++i)&#123;                is[0] = (i + &#39;a&#39;);                if(!s.count(is)) cnt[pre][i]++;            &#125;        &#125;        ll ans = 0;        for(int i = 0; i &lt; 26; ++i)&#123;            for(int j = 0; j &lt; 26; ++j) ans += cnt[i][j] * cnt[j][i];        &#125;        return ans;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dfs 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake是如何工作的</title>
      <link href="/2022/06/21/yu-yan/cmake/cmake-shi-ru-he-gong-zuo-de/"/>
      <url>/2022/06/21/yu-yan/cmake/cmake-shi-ru-he-gong-zuo-de/</url>
      
        <content type="html"><![CDATA[<h1><span id="cmake是如何工作的">CMake是如何工作的</span></h1><p>[toc]</p><p>出错不要慌，首先一定要仔细看报错。在根据报错去解决问题。一定要学会用二分法先定位到问题是哪个地方出来的。</p><p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220621211809803.png" alt="image-20220621211809803"></p><p>首先从图中可以知道，出错是在编译 transport_receiver这个target的时候。但是去找transport_receiver的时候发现包含了头文件目录。</p><p>仔细看FAILED 的信息</p><p>Building CXX object build_report_sdk&#x2F;CMakeFiles&#x2F;reportsdk.dir&#x2F;<strong>&#x2F;</strong>&#x2F;dispatch_queue.cpp.o</p><p>因为CMakeFiles中的文件才是最后编译的参数，进入找到相应的文件，然后根据错误再去修正。</p><p>根据错误，知道是CMakeFiles下面的reportsdk这个target编译的时候找不到头文件。之后找到这个generator产生的编译表示产物，看一下是否真的没有-I参数指定对应的目录。如果没有就找到该targrt添加并重新编译。</p><h2><span id="cmake由来">CMake由来</span></h2><p>Cmake是一个build system。经过多面的发展已经发展为一个系列。开发工具包括CMake、Cpack、CTest、CDash。具体可以看<a href="https://gitlab.kitware.com/cmake/community/-/wikis/Home">cmake gitlab链接</a>。</p><p>CMake是一个是Build工具，负责可执行文件的构建</p><p>CTest是一个测试驱动工具，用于运行测试</p><p>CPack是一个打包工具，用于创建用特定平台用Cmake编译的软件安装包</p><p>CDash是一个Web应用，用于显示测试结果和执行在持续集成测试<a href="https://www.bookstack.cn/read/CMake-Cookbook/content-chapter14-14.2-chinese.md">参考</a></p><p>CMake是如何实现的</p><p>如前所述，CMake是一个元构建系统，可用于为许多其他构建工具创建构建文件.</p><p>使用cmake –help可以查看其生成器。</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220621211851381.png" alt="image-20220621211851381" style="zoom:67%;"><h2><span id="cmake处理过程">CMake处理过程</span></h2><p>CMake主要有两个阶段</p><ul><li><p>Configure CMake处理输入给它的一切，同时创建执行Build的内部表示</p></li><li><p>Generate 创建真正的编译文件</p></li></ul><h3><span id="cmake-configure步骤">CMake Configure步骤</span></h3><ol><li><p>检测CMakeCache.txt是否存在，如果存在就读取</p></li><li><p>读取源目录的根目录下的CMakeLists.txt文件，CMake语言解析器会去解析CMakeLists.txt文件。每一个文件中被发现的命令都会被执行，另外CMakeLists.txt文件可以通过CMake命令 <code>include</code>和  <code>add_subdirectory</code>触发解析。CMake会为每一个命令生成一个可以在CMake语言中使用的C++对象，例如<code>add_library</code> <code>if</code> <code>include</code> 等命令。其实CMake整个语言以命令调用的形式实现的。CMake的语言解析器就干了一件事情，就是把CMake输入的文件转换成命令的调用和这些命令需要的参数(字符串列表)。</p></li></ol><p>CMake其实就是将用户写的CMake语句进行执行，执行完了后在内存中就会生成文件(表示项目的构建)，这些文件中包含了库、可执行文件、自定义命令、选择generator需要的信息。这些都在CMakeCache.txt文件里面。</p><p>内存中的文件有所以需要构建的target(比如库、可执行文件)，用户也可以自定义target(用户可以定义他们的输入、输出、编写他们在运行时自定义的命令或脚本)。CMake把每一个target都保存到一个CmTarget对象中。</p><p>这些对象依次存放到cmMakefile对象中，也就是是在source tree的给定目录中找到的所有目标都会存储到这里。</p><p>总结就是，cmMakeifle包含了所有cmTarget目标。</p><h3><span id="cmake-generate步骤">CMake Generate步骤</span></h3><p>在configure步骤执行之后就可以执行gennerate步骤了。这个步骤就是使用用户指定的编译工具去得到编译的文件和目标产物。在这一步targets(库、可执行文件、用户自定义target)会被转换为IDE编译工具的输入或者是一系列的Makefiles(被make执行)。</p><p>CMake会自动构建依赖，对于generator是Makefiles的项目，Cmake会把项目依赖信息存放在以下四个文件</p><ul><li><p>depend.cmake 存储所有目标的依赖信息</p></li><li><p>flags.cmake 包含目标源文件的编译选项信息，被改变了就需要重新编译</p></li><li><p>build.cmake 编译这些依赖的规则</p></li><li><p>DependInfo.cmake 为了保持编译信息的是最新的，也包含项目这部分的文件，以及他们的语言是什么。当一个目标的依赖过时的时候，就会重新计算目标的依赖。</p></li></ul><p>后面如果想看懂make文件，就需要了解makefile的知识</p><h2><span id="举例">举例</span></h2><p>我有如下CMakeLists.txt</p><pre class=" language-Plain"><code class="language-Plain">cmake_minimum_required(VERSION 3.8)project(native)find_package(Boost CONFIG REQUIRED)message($&#123;Boost_VERSION&#125;)set(CMAKE_BUILD_TYPE Debug)set(CMAKE_MACOSX_RPATH 0)SET(CMAKE_CXX_FLAGS_DEBUG "$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb")add_library(testNative SHARED    common/seg.cc)add_executable($&#123;PROJECT_NAME&#125; main.cc)target_include_directories($&#123;PROJECT_NAME&#125; PUBLIC    ./common)target_link_libraries($&#123;PROJECT_NAME&#125; testNative)</code></pre><p>这时候创建build文件夹，执行cmake .. make之后得到如下表示</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)" alt="img" style="zoom:50%;"><p>打开其中一个target文件，结果如下</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20220621212024158.(null)" alt="img" style="zoom:50%;"><p>XXX.o.d文件包含了inclue文件的地址。</p><p>这时候添加一个test.h文件进去</p><p>报错</p><pre class=" language-Plain"><code class="language-Plain"> fatal error: 'test.h' file not found #include "test.h"</code></pre><p>发现是在编译</p><blockquote><p>[ 25%] Building CXX object CMakeFiles&#x2F;testNative.dir&#x2F;common&#x2F;seg.cc.o</p></blockquote><p>找到testNative目标，查看flags.make</p><pre class=" language-Plain"><code class="language-Plain"># CMAKE generated file: DO NOT EDIT!# Generated by "Unix Makefiles" Generator, CMake Version 3.22# compile CXX with /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++CXX_DEFINES = -DtestNative_EXPORTSCXX_INCLUDES = CXX_FLAGS =  -O0 -Wall -g -ggdb -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk -mmacosx-version-min=12.2 -fPIC</code></pre><p>发现确实没有include进去，这时候修改testNative在CMakeLists.txt的内容，使得包含该头文件。</p><p>重新编译查看testNative target下的flags.make</p><pre class=" language-Plain"><code class="language-Plain"># CMAKE generated file: DO NOT EDIT!# Generated by "Unix Makefiles" Generator, CMake Version 3.22# compile CXX with /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++CXX_DEFINES = -DtestNative_EXPORTSCXX_INCLUDES = -I/Users/bytedance/Documents/Code/C++/native/common/testCXX_FLAGS =  -O0 -Wall -g -ggdb -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.3.sdk -mmacosx-version-min=12.2 -fPIC</code></pre><h2><span id="指定gennerator">指定gennerator</span></h2><p>我们这时候用的是默认的gennerator。我们可以指定gennerator比如Ninja</p><p>Cmake -G Ninja ..</p><p>Ninja</p><p>同样是编译出错，看一下CMakefiles</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/(null)-20220621212030121.(null)" alt="img" style="zoom:50%;"><p>参考Ninja学习资料，主要是rule.ninja 和 build.ninja文件</p><p>其中rule.ninjaa定义了rule,也就是编译执行的命令</p><p>build.ninja 执行真正的build,会给rule中的命令提供输入与输出</p><p>查看ninja.build中对应target的写法，发现</p><blockquote><p>  INCLUDES &#x3D; -I&#x2F;Users&#x2F;bytedance&#x2F;Documents&#x2F;Code&#x2F;C++&#x2F;native&#x2F;.&#x2F;common</p></blockquote><p>确实没有头文件，添加之后</p><blockquote><p>  INCLUDES &#x3D; -I&#x2F;Users&#x2F;bytedance&#x2F;Documents&#x2F;Code&#x2F;C++&#x2F;native&#x2F;common&#x2F;test -I&#x2F;Users&#x2F;bytedance&#x2F;Documents&#x2F;Code&#x2F;C++&#x2F;native&#x2F;.&#x2F;common</p></blockquote><p>就包含在内，问题完美解决。所以一切的根源就是要充分理解问题，定位问题，再去查找问题原因，再解决。不然后面两步会浪费大量的时间与精力。</p><h2><span id="学习资料">学习资料</span></h2><p><a href="https://www.bookstack.cn/read/CMake-Cookbook/README.md">CMake菜谱</a></p><p><a href="http://www.aosabook.org/en/cmake.html#fig.cma.obj">how cmake work</a></p><ul><li><p><a href="https://ninja-build.org/manual.html">Ninja官方手册</a></p></li><li><p><a href="http://www.gnu.org/software/make/manual/make.html">GNU make官方文档</a></p></li><li><p><a href="https://github.com/ninja-build/ninja/wiki/List-of-generators-producing-ninja-build-files">List of generators producing ninja build files</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程认知</title>
      <link href="/2022/06/13/yu-yan/gong-cheng-ren-zhi/gong-cheng-ren-zhi/"/>
      <url>/2022/06/13/yu-yan/gong-cheng-ren-zhi/gong-cheng-ren-zhi/</url>
      
        <content type="html"><![CDATA[<h1><span id></span></h1><h2><span id="思维">思维</span></h2><ul><li><p>对于有关联的数据结构，最好组合在一起，形成类或者是结构体</p></li><li><p>在探索方案的时候，要做到一下几点</p></li></ul><ol><li>整理数据流程功能要走通</li><li>想好如何复用现有的代码，功能而不是自己重写</li><li>要学会提前设计好数据结构，不要没做好就弄，会浪费很多时间</li></ol><ul><li>遇到问题，先分段找到大致的范围， 之后先考虑可能的情况，然后依次排除可能性更高的情况</li></ul><h2><span id="代码">代码</span></h2><ul><li>在编写代码的初期，为了确保代码的准确性，可以适当的添加assert()，方便快速定位代码异常位置。之后再相应的删除代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码习惯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo使用教程</title>
      <link href="/2022/06/12/hexo-shi-yong-jiao-cheng/"/>
      <url>/2022/06/12/hexo-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1><span id="hexo使用教程">Hexo使用教程</span></h1><!-- ttoc --><h2><span id="创建与发布文章">创建与发布文章</span></h2><blockquote><p>hexo new 文章名</p><p>hexo deploy -g 部署</p></blockquote><h2><span id="删除文章">删除文章</span></h2><blockquote><p>直接在source&#x2F;_post文件目录下删除文章，再只想 hexo d -g</p></blockquote><h2><span id="theme更改">theme更改</span></h2><p>首先将自己喜欢的主题下载到theme目录下。</p><p>有两个设置，一个在hexo主目录下面，配置使用哪一个主题(theme字段)，theme目录下面有具体的主题文件，当中含有一个配置文件用于配置细节。</p><p><a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">主题推荐</a></p><p><a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-19">主题使用手册</a></p><h2><span id="安装依赖">安装依赖</span></h2><p>在 <code>hexo init</code>目录下只想 nmp install xxx –save进行安装</p><h2><span id="搭建">搭建</span></h2><ol><li>注册github账号</li><li>新建仓库，注意仓库的名称必须为 用户名.github.io</li><li>初始化仓库 hexo init 文件夹</li><li>hexo d -g 之后打开浏览器访问 用户名.git</li></ol><h3><span id="配置评论功能">配置评论功能</span></h3><p>使用valline配置评论功能。</p><ol><li>首先去valline官网注册一个账号。</li><li>应用中的设置中点击应用凭证，获取AppID AppKey</li><li>然后去_config.yaml上进行配置</li></ol><pre class=" language-c++"><code class="language-c++">valine:  enable: true # 设置为true，默认为false  appid:  # 将应用key的App ID设置在这里  appkey: # 将应用key的App Key设置在这里  notify: false# 邮箱通知 , https://github.com/xCss/Valine/wiki，默认为false  verify: false# 验证码 默认为false  placeholder: Just go go ^_^ # 初始化评论显示，根据自己修改，这里默认，  avatar: monsterid # 头像风格，默认为mm，可进入网址：https://valine.js.org/visitor.html查看头像设置，这里有许多头像风格，进行设置  guest_info: nick,mail,link # 自定义评论标题  pageSize: 10 # 分页大小，10页就自动分页  visitor: true # 是否允许游客评论 ，进入官网查看设置：https://valine.js.org/visitor.html</code></pre><p>最后效果如下：</p><img src="https://zhongsy.oss-cn-beijing.aliyuncs.com/img/image-20220610210620831.png" alt="image-20220610210620831" style="zoom:33%;"><p><a href="https://cloud.tencent.com/developer/article/1965154">更多配置</a></p><h2><span id="自定义域名">自定义域名</span></h2><p>可以花点钱去定义自己的域名，而不需要.github.io了</p><p>具体操作如下</p><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/124607458?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165486692316780366521224%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165486692316780366521224&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-124607458-null-null.142%5Ev13%5Econtrol,157%5Ev14%5Econtrol&utm_term=hexo%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&spm=1018.2226.3001.4187">域名自定义操作</a></p><h2><span id="写文章">写文章</span></h2><h3><span id="配置图床">配置图床</span></h3><p>picgo + 阿里云 + typora</p><p><a href="https://zhuanlan.zhihu.com/p/104152479">配置教程</a></p><h2><span id="插件推荐">插件推荐</span></h2><p>Hexo提供了诸多插件来增强博客体验，地址<code>http://hexo.io/plugins/</code>。</p><ul><li>hexo-toc</li></ul><p>用于生成目录，只需要在生成目录的地方写入 <code>&lt;!-- ttoc --&gt;</code></p><p>安装 <code>npm install hexo-toc --save</code></p><p>在博客根目录下的 <code>_config.yml</code> 中如下配置：</p><pre><code>toc:  maxDepth: 3</code></pre><p><a href="https://yscoder.github.io/20150514/hexo-toc.html">参考</a></p><h2><span id="hexo文档归类">hexo文档归类</span></h2><p>_config.yaml下面有两个配置</p><p><code>permalink</code> 用于设置文章的永久链接格式<br><code>new_post_name</code> 新文章的文件名称</p><p>配置如下命令，即可让新建的文章默认按照年月去分类。<br>在<code>_config.yml</code>文件中修改下面的命令<br><code>new_post_name: :year/:month/:title.md</code></p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5yeXpleWFuZy50b3AvMjAyMDA3MjYwOTI3MjQucG5n?x-oss-process=image/format,png" alt="20200726092724" style="zoom:50%;"><p>通过该命令 <code>hexo new post -p /后端/test.md</code> 执行后，会在post文件夹下创建子文件夹 “后端”，并创建一篇test.md博文。</p><p><a href="https://hexo.io/zh-cn/">hexo官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数返回优化</title>
      <link href="/2022/06/12/yu-yan/c/c-han-shu-fan-hui-you-hua/"/>
      <url>/2022/06/12/yu-yan/c/c-han-shu-fan-hui-you-hua/</url>
      
        <content type="html"><![CDATA[<h1><span id="c函数返回优化">C++函数返回优化</span></h1><p>我们知道，函数运行结束后，函数内部的局部变量就会消失，当函数返回的对象的时候，会产生一个临时对象，这样会消耗很多的计算资源，写一段代码进行测试。</p><pre class=" language-c++"><code class="language-c++">#include <iostream>using namespace std;class MyBuff &#123; public:  MyBuff() &#123;    cout << "MyBuff()" << endl;  &#125;  MyBuff(const MyBuff& b) = delete;  MyBuff& operator=(const MyBuff& b) = delete;  ~MyBuff() &#123;    cout << "~MyBuff()" << endl;  &#125;  MyBuff(MyBuff&& b) noexcept &#123; cout << "move construct" << endl; &#125;  MyBuff& operator=(MyBuff&& b) noexcept &#123;    cout << "move assign " << endl;    return *this;  &#125;&#125;;class bbuffer &#123; public:  bbuffer() &#123;&#125;  void show() &#123; cout << "sh bbuffer" << endl; &#125;  ~bbuffer() &#123;&#125;&#125;;MyBuff GetBuff() &#123;  MyBuff res;  cout << &res << endl;  bbuffer b_;  b_.show();  return res;&#125;int main() &#123;  MyBuff b = GetBuff();  cout << &b << endl;&#125;</iostream></code></pre><p>执行结果如下：</p><pre><code>MyBuff()0x7ff7bb322258show bbuffer0x7ff7bb322258~MyBuff()</code></pre><p>是不是感觉和理解的不对，这时候好像并没有产生一个临时的对象，我们发现b和临时对象res的地址是一样的，并且res的析构是在整个程序结束的时候执行的，难道编译器进行了优化。</p><p>之后百度发现有一种优化叫做返回值优化机制，<a href="https://www.cnblogs.com/xkfz007/archive/2012/07/21/2602110.html">传送门</a>，编译时候加入参数 -fno-elide-constructors优化。</p><p>从新执行代码结果如下</p><pre><code>MyBuff()0x7ff7b2e2a200show bbuffermove construct~MyBuff()move construct~MyBuff()0x7ff7b2e2a258~MyBuff()</code></pre><p>这时候</p><p>MyBuff()是在GetBuff()函数内部进行构造。</p><p>返回的时候生成临时变量，(函数的返回值为右值)触发一次移动构造，之后析构res.</p><p>之后临时变量用来构造main中的c，之后析构</p><p>函数执行完成，c被析构。</p><p>为什么没有调用移动赋值构造，<a href="https://www.jianshu.com/p/fb2440750f70">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大小端详解</title>
      <link href="/2022/06/12/yu-yan/c/da-xiao-duan/"/>
      <url>/2022/06/12/yu-yan/c/da-xiao-duan/</url>
      
        <content type="html"><![CDATA[<h1><span id="大小端详解">大小端详解</span></h1><p> [toc]</p><h2><span id="大小端原理">大小端原理</span></h2><p>大小端出现的原因在于：在计算机中，&#x3D;&#x3D;数据都是按照字节去进行存储的(所以如果是单字节的问题就不涉及到大小端)&#x3D;&#x3D;，但是对于多字节(int,long等)就会涉及到数据的存储顺序的问题，这也就出现了两种常见的存储方式</p><ul><li>Big endian : 大端存储，大端存储是高字节在前面(低地址)，低字节在后面(高地址)</li><li>Little endiam ：小端存储，小端存储是高字节在后面(高地址)，低字节在前面(低地址)</li></ul><p>不同的cpu可能有不同的模型</p><p>优点</p><ul><li>大端模式，由于高位在低地址，所以很容易判断正负</li><li>小端模式，强制抓换数据的时候，不需要调整字节内容</li></ul><p>以0x1234为例进行说明。</p><table><thead><tr><th>地址</th><th>0x4000（低地址）</th><th>0x4001（高地址）</th></tr></thead><tbody><tr><td>大端存储</td><td>0x12</td><td>0x34</td></tr><tr><td>小端存储</td><td>0x34</td><td>0x12</td></tr></tbody></table><h2><span id="大小端验证">大小端验证</span></h2><h3><span id="c验证">C++验证</span></h3><p>C++判断大小端可以借用Union，union在某种程度上和struct是一种数据结构</p><p>相同点</p><ul><li>都可以包含不同的数据类型和变量</li></ul><p>不同点</p><ul><li>struct是所有数据&#x3D;&#x3D;共存&#x3D;&#x3D;，有容乃大，不管struct内的数据结构用不用，都会为其分配内存</li><li>union是各种变量互斥的存在。其实就是共用一块内存地址。union的大小取决与里面内存对齐后最大的那个。</li></ul><p><a href="https://blog.csdn.net/ahelloyou/article/details/118488687?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165475505716782395384248%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165475505716782395384248&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-118488687-null-null.nonecase&utm_term=%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90&spm=1018.2226.3001.4450">内存对齐知识点</a></p><p>这时候就可以利用union去判断大小端。</p><pre class=" language-c++"><code class="language-c++">union U &#123;  char ch[4];  int var;&#125; test;这时候U的sizeof为4我们进行如下的赋值操作  test.ch[0] = 0x00u; // 低地址  test.ch[1] = 0x00u; // +    test.ch[2] = 0x00u; // +    test.ch[3] = 0x01u; // 高地址                                                            高位(32) -    -   低位(0)如果是大端模式，那么高位放到低地址为 0x00u 0x00u 0x00u 0x01u如果是小端模式，那么高位放在高地址为 0x01u 0x00u 0x00u 0x00u如果test.val == 1那么就是大端模式，反之就是小端。</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> c++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 464. 我能赢吗</title>
      <link href="/2022/06/12/yu-yan/leetcode/dfs/464-wo-neng-ying-ma/"/>
      <url>/2022/06/12/yu-yan/leetcode/dfs/464-wo-neng-ying-ma/</url>
      
        <content type="html"><![CDATA[<h4><span id="464-我能赢吗"></span></h4><p>难度中等370收藏分享切换为英文接收动态反馈</p><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 <code>1</code> 到 <code>10</code> 的任意整数，累计整数和，先使得累计整数和 <strong>达到或超过</strong> 100 的玩家，即为胜者。</p><p>如果我们将游戏规则改为 “玩家 <strong>不能</strong> 重复使用整数” 呢？</p><p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;&#x3D; 100。</p><p>给定两个整数 <code>maxChoosableInteger</code> （整数池中可选择的最大数）和 <code>desiredTotal</code>（累计和），若先出手的玩家是否能稳赢则返回 <code>true</code> ，否则返回 <code>false</code> 。假设两位玩家游戏时都表现 <strong>最佳</strong> 。</p><p><strong>示例 1：</strong></p><pre><code>输入：maxChoosableInteger = 10, desiredTotal = 11输出：false解释：无论第一个玩家选择哪个整数，他都会失败。第一个玩家可以选择从 1 到 10 的整数。如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入：maxChoosableInteger = 10, desiredTotal = 0输出：true</code></pre><p><strong>示例 3:</strong></p><pre><code>输入：maxChoosableInteger = 10, desiredTotal = 1输出：true</code></pre><h3><span id="思路">思路</span></h3><p>首先想到的是暴力解法，也就就将每一种情况都遍历一遍。其实动态规划，也是在记忆dfs的基础上进行的，也就是其中一个是正向遍历(自顶向下)，一个是递归逆向的(自底向上)。</p><p>那么怎么去记忆化。也就是找到变量并将其记录下来，下次再次遇到的时候就可以直接得到结果。</p><p>这里的变量是，</p><ul><li>我们取的数和剩余的数(这里用二进制去表示取的数，因为m&lt;&#x3D;20,也就是20位，这样就可以用statae代表，而visited[state]记录着这个状态下的结果)</li><li>sum</li></ul><p>依照这个思路写下代码如下；</p><pre class=" language-c++"><code class="language-c++">class Solution &#123;private:    // visited[i] == 0，说明没有计算过    // visited[i] == 1，说明计算过，结果为 true    // visited[i] == 2，说明计算过，结果为 false    int visited[1 << 21];public:    bool canIWin(int maxChoosableInteger, int desiredTotal) &#123;        // 判断当前做选择的玩家（先手），是否一定赢        // 开始时，state = 0，表示「公共整数集」中的所有数字都未被使用过         if (maxChoosableInteger >= desiredTotal)            return true;        if (maxChoosableInteger * (maxChoosableInteger + 1) < 2*desiredTotal)            return false;        return dfs(0, 0, maxChoosableInteger, desiredTotal);    &#125;        // 当前做选择的玩家是否一定赢    bool dfs(int state, int sum, int maxChoosableInteger, int desiredTotal) &#123;        if (visited[state] == 1) return true;        if (visited[state] == 2) return false;        // 遍历可选择的公共整数        for (int x = 1; x <= maxchoosableinteger; ++x) &#123; 如果 x 已经被使用过了，则不能选择 if ((1 << x) & state) continue; 如果选择了 以后，大于等于了 desiredtotal，当前玩家赢 (sum +>= desiredTotal) &#123;                visited[state] = 1;                return true;            &#125;            // 当前玩家选择了 x 以后，判断对方玩家一定输吗？            if (!dfs((1 << x) | state, sum + x, maxChoosableInteger, desiredTotal)) &#123;                visited[state] = 1;                return true;            &#125;        &#125;        visited[state] = 2;        return false;    &#125;    &#125;;</=></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语句提取数据存入excel</title>
      <link href="/2022/06/12/yu-yan/python/python-jiao-ben/yu-ju-ti-qu-shu-ju-cun-ru-excel/"/>
      <url>/2022/06/12/yu-yan/python/python-jiao-ben/yu-ju-ti-qu-shu-ju-cun-ru-excel/</url>
      
        <content type="html"><![CDATA[<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token keyword">from</span> re <span class="token keyword">import</span> X<span class="token keyword">import</span> xlwt<span class="token keyword">import</span> xlrd<span class="token keyword">def</span> <span class="token function">calculate_average</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># print(lst)</span>    sum <span class="token operator">=</span> <span class="token number">0</span>    acc <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> val <span class="token keyword">in</span> lst<span class="token punctuation">:</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        sum <span class="token operator">+=</span> int<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        acc <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>acc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">return</span> sum<span class="token operator">/</span>acc<span class="token keyword">def</span> <span class="token function">find_num</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>    p_1 <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    raw_1 <span class="token operator">=</span> p_1<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>str<span class="token punctuation">)</span>    str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>raw_1<span class="token punctuation">)</span>    p_2 <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"[0-9]+"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> p_2<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">write_file</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>    book <span class="token operator">=</span> xlwt<span class="token punctuation">.</span>Workbook<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建Workbook，相当于创建Excel</span>    <span class="token comment" spellcheck="true"># 创建sheet，Sheet1为表的名字，cell_overwrite_ok为是否覆盖单元格</span>    sheet1 <span class="token operator">=</span> book<span class="token punctuation">.</span>add_sheet<span class="token punctuation">(</span>u<span class="token string">'Sheet1'</span><span class="token punctuation">,</span> cell_overwrite_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    row <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>val<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span>row<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        row <span class="token operator">=</span> row<span class="token operator">+</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># write average</span>    sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span>row<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"average"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sheet1<span class="token punctuation">.</span>write<span class="token punctuation">(</span>row<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> calculate_average<span class="token punctuation">(</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    book<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'/Users/bytedance/Documents/csv_1.0.xls'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    key <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Lock"</span><span class="token punctuation">,</span> <span class="token string">"eglmake"</span><span class="token punctuation">,</span> <span class="token string">"draw"</span><span class="token punctuation">,</span> <span class="token string">"buf"</span><span class="token punctuation">,</span> <span class="token string">"render"</span><span class="token punctuation">,</span> <span class="token string">"all"</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'/Users/bytedance/Documents/csv_1.0.log'</span><span class="token punctuation">,</span> <span class="token string">'r+'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fd<span class="token punctuation">:</span>        val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># for i in range(len(key)):</span>        <span class="token comment" spellcheck="true"># val[i].append([])</span>        <span class="token comment" spellcheck="true"># val[i].pop()</span>        <span class="token keyword">for</span> text <span class="token keyword">in</span> fd<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># print(text)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                v <span class="token operator">=</span> find_num<span class="token punctuation">(</span>text<span class="token punctuation">,</span> key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">": [0-9]+"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># print(v)</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>        write_file<span class="token punctuation">(</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>post</title>
      <link href="/2022/06/10/yin-shi-pin-ji-chu/rtc/rtc-suan-fa-ji-chu/"/>
      <url>/2022/06/10/yin-shi-pin-ji-chu/rtc/rtc-suan-fa-ji-chu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/10/hello-world/"/>
      <url>/2022/06/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
